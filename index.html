<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Tetris Mobile Game</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<style>
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 0;
    background: linear-gradient(135deg, #3f51b5, #9c27b0);
    color: #eee;
    font-family: 'Press Start 2P', cursive, monospace;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    user-select: none;
  }
  #menuScreen, #gameOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 999;
    text-shadow: 0 0 10px #fff;
  }
  #menuScreen h1 {
    font-size: 2.8em;
    color: #ff4081;
    margin-bottom: 40px;
    text-shadow:
      0 0 10px #ff4081,
      0 0 20px #e040fb,
      0 0 30px #7c4dff;
  }
  button {
    font-family: 'Press Start 2P', cursive, monospace;
    cursor: pointer;
    border: none;
    border-radius: 15px;
    padding: 20px 40px;
    font-size: 1em;
    color: #fff;
    background: linear-gradient(45deg, #ff4081, #7c4dff);
    box-shadow:
      0 0 15px #ff4081,
      0 0 30px #7c4dff;
    transition: all 0.3s ease;
    user-select: none;
  }
  button:hover {
    background: linear-gradient(45deg, #e040fb, #651fff);
    box-shadow:
      0 0 20px #e040fb,
      0 0 40px #651fff;
    transform: scale(1.05);
  }
  button:active {
    transform: scale(0.95);
    box-shadow: none;
  }
  #scoreLevel {
    margin: 12px 0;
    font-size: 1.2em;
    text-align: center;
    text-shadow: 0 0 8px #fff;
  }
  #gameContainer {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: 12px;
    width: 100%;
    max-width: 460px;
    padding: 10px;
    background: rgba(0,0,0,0.3);
    border-radius: 15px;
    box-shadow:
      0 0 15px #7c4dff,
      inset 0 0 20px #e040fb;
  }
  canvas {
    image-rendering: pixelated;
    background: #111;
    border-radius: 12px;
    border: 4px solid transparent;
    box-shadow:
      0 0 15px #7c4dff,
      inset 0 0 40px #e040fb;
  }
  #game {
    width: 300px;
    height: 600px;
  }
  #next {
    width: 140px;
    height: 140px;
    margin-top: 40px;
  }
  #controls {
    display: flex;
    justify-content: center;
    gap: 15px;
    padding: 12px 10px;
    flex-wrap: wrap;
    width: 100%;
    max-width: 460px;
    margin-top: 15px;
  }
  #controls button {
    flex: 1 1 60px;
    padding: 18px 0;
    font-size: 1.4em;
    border-radius: 12px;
    background: linear-gradient(135deg, #651fff, #d500f9);
    box-shadow:
      0 0 15px #d500f9,
      inset 0 0 10px #651fff;
    transition: all 0.3s ease;
    max-width: 80px;
    color: #fff;
    user-select: none;
  }
  #controls button:active {
    background: linear-gradient(135deg, #d500f9, #651fff);
    box-shadow: none;
    transform: scale(0.9);
  }
  #pauseBtn, #resumeBtn {
    max-width: 120px;
    font-size: 1.1em;
    background: linear-gradient(135deg, #ff1744, #f50057);
    box-shadow:
      0 0 20px #f50057,
      inset 0 0 15px #ff1744;
    margin-left: 10px;
  }
  #pauseBtn:hover, #resumeBtn:hover {
    background: linear-gradient(135deg, #f50057, #c51162);
    box-shadow:
      0 0 25px #c51162,
      inset 0 0 20px #f50057;
  }
  #gameOverlay div {
    color: #ff1744;
    font-size: 3em;
    text-shadow:
      0 0 10px #ff1744,
      0 0 20px #f50057;
    margin-bottom: 30px;
  }
  @media (max-width: 400px) {
    #game { width: 240px; height: 480px; }
    #next { width: 110px; height: 110px; margin-top: 30px; }
    #controls button { font-size: 1.2em; max-width: 65px; padding: 15px 0; }
    #pauseBtn, #resumeBtn { max-width: 100px; font-size: 1em; margin-left: 5px;}
  }
</style>
</head>
<body>

<div id="menuScreen">
  <h1>TETRIS MOBILE</h1>
  <button id="startBtn">เริ่มเล่น</button>
</div>

<div id="gameOverlay" style="display:none;">
  <div>เกมจบ!</div>
  <button id="restartBtn">เล่นใหม่</button>
</div>

<div id="scoreLevel">
  คะแนน: <span id="score">0</span> | ระดับ: <span id="level">1</span>
</div>

<div id="gameContainer">
  <canvas id="game" width="300" height="600"></canvas>
  <canvas id="next" width="140" height="140"></canvas>
</div>

<div id="controls">
  <button id="leftBtn">←</button>
  <button id="rightBtn">→</button>
  <button id="rotateBtn">⟳</button>
  <button id="downBtn">↓</button>
  <button id="pauseBtn">หยุดชั่วคราว</button>
  <button id="resumeBtn" style="display:none;">เล่นต่อ</button>
</div>

<script>
  // --- โค้ดเกม Tetris (ตัวอย่าง simplified ปรับให้เหมาะสม) ---

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const menuScreen = document.getElementById('menuScreen');
  const gameOverlay = document.getElementById('gameOverlay');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');

  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const rotateBtn = document.getElementById('rotateBtn');
  const downBtn = document.getElementById('downBtn');

  const COLS = 10;
  const ROWS = 20;
  const BLOCK_SIZE = 30;

  canvas.width = COLS * BLOCK_SIZE;
  canvas.height = ROWS * BLOCK_SIZE;

  const colors = [
    null,
    '#ff1744', // I
    '#651fff', // J
    '#00e676', // L
    '#ffea00', // O
    '#d500f9', // S
    '#2979ff', // T
    '#ff9100', // Z
  ];

  // Tetromino shapes
  const SHAPES = [
    [],
    [[1,1,1,1]], // I
    [[2,0,0],[2,2,2]], // J
    [[0,0,3],[3,3,3]], // L
    [[4,4],[4,4]], // O
    [[0,5,5],[5,5,0]], // S
    [[0,6,0],[6,6,6]], // T
    [[7,7,0],[0,7,7]], // Z
  ];

  // Helper functions

  function createMatrix(w,h) {
    const matrix = [];
    while(h--) matrix.push(new Array(w).fill(0));
    return matrix;
  }

  function drawMatrix(ctx, matrix, offset) {
    matrix.forEach((row,y) => {
      row.forEach((value,x) => {
        if(value !== 0) {
          ctx.fillStyle = colors[value];
          ctx.fillRect((x + offset.x)*BLOCK_SIZE, (y + offset.y)*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          ctx.strokeStyle = '#222';
          ctx.lineWidth = 2;
          ctx.strokeRect((x + offset.x)*BLOCK_SIZE, (y + offset.y)*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      });
    });
  }

  function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for(let y=0; y < m.length; ++y){
      for(let x=0; x < m[y].length; ++x){
        if(m[y][x] !== 0 &&
           (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0){
          return true;
        }
      }
    }
    return false;
  }

  function merge(arena, player) {
    player.matrix.forEach((row,y) => {
      row.forEach((value,x) => {
        if(value !== 0) {
          arena[y + player.pos.y][x + player.pos.x] = value;
        }
      });
    });
  }

  function rotate(matrix, dir) {
    for(let y=0; y < matrix.length; ++y){
      for(let x=0; x < y; ++x){
        [
          matrix[x][y],
          matrix[y][x],
        ] = [
          matrix[y][x],
          matrix[x][y],
        ];
      }
    }
    if(dir > 0){
      matrix.forEach(row => row.reverse());
    } else {
      matrix.reverse();
    }
  }

  function playerReset() {
    const pieces = 'TJLOSZI';
    player.matrix = createPiece(pieces[pieces.length * Math.random() | 0]);
    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
    if(collide(arena, player)) {
      arena.forEach(row => row.fill(0));
      score = 0;
      level = 1;
      dropInterval = 1000;
      gameOver();
      updateScore();
    }
  }

  function createPiece(type) {
    switch(type){
      case 'T': return [
        [0,6,0],
        [6,6,6],
      ];
      case 'O': return [
        [4,4],
        [4,4],
      ];
      case 'L': return [
        [0,0,3],
        [3,3,3],
      ];
      case 'J': return [
        [2,0,0],
        [2,2,2],
      ];
      case 'I': return [
        [1,1,1,1],
      ];
      case 'S': return [
        [0,5,5],
        [5,5,0],
      ];
      case 'Z': return [
        [7,7,0],
        [0,7,7],
      ];
    }
  }

  function arenaSweep() {
    let rowCount = 1;
    outer: for(let y = arena.length -1; y >= 0; --y){
      for(let x = 0; x < arena[y].length; ++x){
        if(arena[y][x] === 0){
          continue outer;
        }
      }
      const row = arena.splice(y,1)[0].fill(0);
      arena.unshift(row);
      score += rowCount * 10;
      rowCount *= 2;
      // เพิ่มแอนิเมชันกระพริบแถวก่อนลบ
      animateClearRow(y);
      y++; // ตรวจซ้ำแถวที่เลื่อนลงมา
    }
  }

  let animatingClear = false;
  function animateClearRow(rowY) {
    animatingClear = true;
    let blinkCount = 0;
    const blinkInterval = setInterval(() => {
      for(let x=0; x < arena[rowY].length; x++){
        arena[rowY][x] = (blinkCount % 2) ? 0 : 8; // 8 = เฉดสีกระพริบ (ต้องกำหนดสีเพิ่มใน colors)
      }
      draw();
      blinkCount++;
      if(blinkCount > 5){
        clearInterval(blinkInterval);
        animatingClear = false;
        arena.splice(rowY, 1);
        arena.unshift(new Array(COLS).fill(0));
      }
    }, 100);
  }

  // เพิ่มสี 8 สำหรับกระพริบ
  colors[8] = '#ffffff';

  function updateScore() {
    scoreEl.innerText = score;
    levelEl.innerText = level;
  }

  function gameOver() {
    gameRunning = false;
    gameOverlay.style.display = 'flex';
  }

  function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    drawMatrix(ctx, arena, {x:0, y:0});
    drawMatrix(ctx, player.matrix, player.pos);
  }

  function drawNext() {
    nextCtx.fillStyle = '#111';
    nextCtx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
    drawMatrix(nextCtx, nextPiece.matrix, {x:1, y:1});
  }

  let arena = createMatrix(COLS, ROWS);
  let player = {
    pos: {x:0, y:0},
    matrix: null,
  };
  let nextPiece = {
    matrix: null,
  };

  let dropCounter = 0;
  let dropInterval = 1000;
  let lastTime = 0;
  let score = 0;
  let level = 1;
  let gameRunning = false;

  function update(time = 0) {
    if(!gameRunning) return;
    const deltaTime = time - lastTime;
    lastTime = time;

    dropCounter += deltaTime;
    if(dropCounter > dropInterval){
      player.pos.y++;
      if(collide(arena, player)){
        player.pos.y--;
        merge(arena, player);
        arenaSweep();
        playerReset();
        updateScore();
        // ปรับเลเวลและความเร็ว
        if(score >= level * 100){
          level++;
          dropInterval *= 0.9;
        }
      }
      dropCounter = 0;
    }
    draw();
    drawNext();
    requestAnimationFrame(update);
  }

  function playerMove(dir) {
    player.pos.x += dir;
    if(collide(arena, player)){
      player.pos.x -= dir;
    }
  }

  function playerRotate(dir) {
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while(collide(arena, player)){
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if(offset > player.matrix[0].length){
        rotate(player.matrix, -dir);
        player.pos.x = pos;
        return;
      }
    }
  }

  function playerDrop() {
    player.pos.y++;
    if(collide(arena, player)){
      player.pos.y--;
      merge(arena, player);
      arenaSweep();
      playerReset();
      updateScore();
    }
    dropCounter = 0;
  }

  // ปุ่มควบคุมมือถือ
  leftBtn.addEventListener('click', () => {
    if(!gameRunning) return;
    playerMove(-1);
    draw();
  });
  rightBtn.addEventListener('click', () => {
    if(!gameRunning) return;
    playerMove(1);
    draw();
  });
  rotateBtn.addEventListener('click', () => {
    if(!gameRunning) return;
    playerRotate(1);
    draw();
  });
  downBtn.addEventListener('click', () => {
    if(!gameRunning) return;
    playerDrop();
    draw();
  });

  // เริ่มเกม
  startBtn.addEventListener('click', () => {
    menuScreen.style.display = 'none';
    gameOverlay.style.display = 'none';
    resetGame();
    gameRunning = true;
    updateScore();
    update();
  });

  // เล่นใหม่
  restartBtn.addEventListener('click', () => {
    gameOverlay.style.display = 'none';
    resetGame();
    gameRunning = true;
    update();
  });

  // หยุดชั่วคราว
  pauseBtn.addEventListener('click', () => {
    gameRunning = false;
    pauseBtn.style.display = 'none';
    resumeBtn.style.display = 'inline-block';
  });

  // เล่นต่อ
  resumeBtn.addEventListener('click', () => {
    gameRunning = true;
    lastTime = performance.now();
    pauseBtn.style.display = 'inline-block';
    resumeBtn.style.display = 'none';
    update();
  });

  function resetGame() {
    arena = createMatrix(COLS, ROWS);
    playerReset();
    nextPiece.matrix = createPiece('TJLOSZI'[Math.floor(Math.random()*7)]);
    score = 0;
    level = 1;
    dropInterval = 1000;
    updateScore();
  }

</script>

</body>
</html>
