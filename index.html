<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tetris Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      font-family: 'Press Start 2P', cursive;
      background: #000;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding: 10px;
    }
    #menuScreen, #gameOverlay {
      text-align: center;
      margin-top: 40px;
    }
    #topUI {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 10px 0;
    }
    #scoreLevel {
      font-size: 12px;
      line-height: 1.5;
      text-align: center;
    }
    #next {
      background-color: #111;
      border: 2px solid #fff;
      width: 80px;
      height: 80px;
    }
    #gameContainer {
      margin-top: 10px;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-top: 15px;
      padding: 10px;
    }
    #controls button {
      width: 22vw;
      max-width: 70px;
      height: 50px;
      font-size: 18px;
      border-radius: 10px;
    }
    @media (max-width: 500px) {
      #controls button {
        width: 20vw;
        max-width: 50px;
        height: 36px;
        font-size: 13px;
        padding: 0;
      }
      #controls {
        gap: 5px;
        padding: 5px;
      }
      #gameContainer {
        margin-top: 2px;
      }
    }
  </style>
</head>
<body>
  <div id="menuScreen">
    <h1>TETRIS</h1>
    <button id="startBtn">Start Game</button>
  </div>
  <div id="gameOverlay" style="display: none;">
    <div id="topUI">
      <canvas id="next"></canvas>
      <div id="scoreLevel">
        <div>Score: <span id="score">0</span></div>
        <div>Level: <span id="level">1</span></div>
        <button id="pauseBtn">Pause</button>
        <button id="resumeBtn" style="display: none;">Resume</button>
        <button id="restartBtn">Restart</button>
      </div>
    </div>
    <div id="gameContainer">
      <canvas id="game" width="200" height="400"></canvas>
    </div>
    <div id="controls">
      <button id="leftBtn">←</button>
      <button id="rightBtn">→</button>
      <button id="rotateBtn">⟳</button>
      <button id="downBtn">↓</button>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('next');
    const nextCtx = nextCanvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const menuScreen = document.getElementById('menuScreen');
    const gameOverlay = document.getElementById('gameOverlay');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');

    const ROWS = 20, COLS = 10, BLOCK_SIZE = canvas.width / COLS;
    const SHAPES = [
      [],
      [[1,1,1,1]], [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]],
      [[1,1,1],[0,1,0]], [[1,1],[1,1]], [[1,0,0],[1,1,1]],
      [[0,0,1],[1,1,1]]
    ];
    const COLORS = [null, '#0ff','#f00','#0f0','#a0f','#ff0','#f80','#00f'];

    let board = [], currentPiece, nextPiece, score = 0, level = 1, linesCleared = 0;
    let dropInterval = 1000, lastDropTime = 0, gameOver = false, isPaused = false;

    function resetBoard() {
      board = Array.from({ length: ROWS }, () => new Array(COLS).fill(0));
    }
    function drawCell(x, y, color, ctxRef) {
      ctxRef.fillStyle = color;
      ctxRef.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    }
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      board.forEach((row, y) => row.forEach((cell, x) => {
        if (cell) drawCell(x, y, COLORS[cell], ctx);
      }));
    }
    function drawPiece(piece, ctxRef) {
      piece.shape.forEach((row, y) => row.forEach((val, x) => {
        if (val) drawCell(piece.x + x, piece.y + y, piece.color, ctxRef);
      }));
    }
    function randomPiece() {
      const id = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
      return {
        id, shape: SHAPES[id], color: COLORS[id],
        x: Math.floor(COLS / 2) - Math.ceil(SHAPES[id][0].length / 2), y: 0
      };
    }
    function mergePiece() {
      currentPiece.shape.forEach((row, y) => row.forEach((val, x) => {
        if (val) board[currentPiece.y + y][currentPiece.x + x] = currentPiece.id;
      }));
    }
    function isValidMove(piece, dx, dy, rotatedShape = piece.shape) {
      return rotatedShape.every((row, y) => row.every((val, x) => {
        if (!val) return true;
        const newX = piece.x + x + dx;
        const newY = piece.y + y + dy;
        return newX >= 0 && newX < COLS && newY < ROWS && (!board[newY] || !board[newY][newX]);
      }));
    }
    function rotate(shape) {
      return shape[0].map((_, i) => shape.map(row => row[i])).reverse();
    }
    function drop() {
      if (!isValidMove(currentPiece, 0, 1)) {
        mergePiece();
        clearLines();
        currentPiece = nextPiece;
        nextPiece = randomPiece();
        if (!isValidMove(currentPiece, 0, 0)) {
          gameOver = true;
          cancelAnimationFrame(animationFrameId);
          alert('Game Over!');
          return;
        }
      } else {
        currentPiece.y++;
      }
    }
    function clearLines() {
      let lines = 0;
      board = board.filter(row => {
        if (row.every(cell => cell)) {
          lines++;
          return false;
        }
        return true;
      });
      while (board.length < ROWS) board.unshift(new Array(COLS).fill(0));
      if (lines) {
        score += lines * 10;
        linesCleared += lines;
        level = Math.floor(linesCleared / 10) + 1;
        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
      }
    }
    function update(time = 0) {
      if (gameOver || isPaused) return;
      if (time - lastDropTime > dropInterval) {
        drop();
        lastDropTime = time;
      }
      drawBoard();
      drawPiece(currentPiece, ctx);
      drawNext();
      scoreEl.textContent = score;
      levelEl.textContent = level;
      animationFrameId = requestAnimationFrame(update);
    }
    function drawNext() {
      nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
      nextPiece.shape.forEach((row, y) => row.forEach((val, x) => {
        if (val) {
          nextCtx.fillStyle = nextPiece.color;
          nextCtx.fillRect(x * 20, y * 20, 19, 19);
        }
      }));
    }
    function startGame() {
      menuScreen.style.display = 'none';
      gameOverlay.style.display = 'block';
      resetBoard();
      currentPiece = randomPiece();
      nextPiece = randomPiece();
      score = 0;
      level = 1;
      linesCleared = 0;
      dropInterval = 1000;
      gameOver = false;
      isPaused = false;
      lastDropTime = 0;
      update();
    }
    startBtn.onclick = startGame;
    restartBtn.onclick = startGame;
    pauseBtn.onclick = () => {
      isPaused = true;
      pauseBtn.style.display = 'none';
      resumeBtn.style.display = 'inline';
    };
    resumeBtn.onclick = () => {
      isPaused = false;
      lastDropTime = performance.now();
      resumeBtn.style.display = 'none';
      pauseBtn.style.display = 'inline';
      update();
    };
    document.getElementById('leftBtn').onclick = () => {
      if (isValidMove(currentPiece, -1, 0)) currentPiece.x--;
    };
    document.getElementById('rightBtn').onclick = () => {
      if (isValidMove(currentPiece, 1, 0)) currentPiece.x++;
    };
    document.getElementById('downBtn').onclick = () => {
      if (isValidMove(currentPiece, 0, 1)) currentPiece.y++;
    };
    document.getElementById('rotateBtn').onclick = () => {
      const rotated = rotate(currentPiece.shape);
      if (isValidMove(currentPiece, 0, 0, rotated)) currentPiece.shape = rotated;
    };
  </script>
</body>
</html>
