<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tetris Mobile</title>
  <style>
    body {
      margin: 0;
      background: #000;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #fff;
    }
    canvas {
      background: #111;
      margin-top: 10px;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 10px;
      padding: 10px;
      gap: 10px;
    }
    #controls button {
      width: 22vw;
      max-width: 70px;
      height: 50px;
      font-size: 1.2em;
    }
    #menu {
      margin-top: 20px;
    }
    #gameOver {
      display: none;
      font-size: 1.5em;
      margin-top: 10px;
    }
  </style>
</head>
<body>

  <div id="menu">
    <button id="startBtn">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°</button>
  </div>

  <canvas id="game" width="240" height="400"></canvas>
  <div id="gameOver">‡πÄ‡∏Å‡∏°‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß! <button id="restartBtn">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà</button></div>

  <div id="controls">
    <button onclick="move('left')">‚¨ÖÔ∏è</button>
    <button onclick="rotate()">üîÑ</button>
    <button onclick="move('right')">‚û°Ô∏è</button>
    <button onclick="drop()">‚¨áÔ∏è</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const ROWS = 20;
    const COLS = 10;
    const BLOCK_SIZE = 20;

    const board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));

    const colors = ['#000', '#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff', '#fff'];

    const pieces = [
      [[1, 1, 1, 1]],
      [[1, 1], [1, 1]],
      [[0, 1, 0], [1, 1, 1]],
      [[1, 1, 0], [0, 1, 1]],
      [[0, 1, 1], [1, 1, 0]],
      [[1, 0, 0], [1, 1, 1]],
      [[0, 0, 1], [1, 1, 1]]
    ];

    const sounds = {
      move: new Audio('move.wav'),
      rotate: new Audio('rotate.wav'),
      drop: new Audio('drop.wav'),
      clear: new Audio('clear.wav'),
      gameover: new Audio('gameover.wav')
    };

    function play(name) {
      const sound = sounds[name];
      if (sound) {
        sound.currentTime = 0;
        sound.play();
      }
    }

    let current, x, y;
    let gameInterval;

    function drawBlock(x, y, colorIndex) {
      ctx.fillStyle = colors[colorIndex];
      ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) drawBlock(c, r, board[r][c]);
        }
      }
      if (current) {
        current.forEach((row, i) => {
          row.forEach((val, j) => {
            if (val) drawBlock(x + j, y + i, val);
          });
        });
      }
    }

    function collide(px, py, shape) {
      return shape.some((row, i) => row.some((val, j) => val && (board[py + i]?.[px + j] || py + i >= ROWS || px + j < 0 || px + j >= COLS)));
    }

    function merge() {
      current.forEach((row, i) => {
        row.forEach((val, j) => {
          if (val) board[y + i][x + j] = val;
        });
      });
    }

    async function clearLines() {
      let lines = [];
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(v => v)) lines.unshift(r);
      }
      if (!lines.length) return;

      play('clear');

      for (let i = 0; i < 3; i++) {
        lines.forEach(r => board[r].fill(i % 2 ? 8 : 0));
        drawBoard();
        await new Promise(res => setTimeout(res, 100));
      }

      lines.forEach(r => {
        board.splice(r, 1);
        board.unshift(Array(COLS).fill(0));
      });
    }

    function spawn() {
      const id = Math.floor(Math.random() * pieces.length);
      current = pieces[id].map(r => r.map(c => c * (id + 1)));
      x = 3;
      y = 0;
      if (collide(x, y, current)) endGame();
    }

    function move(dir) {
      if (!current) return;
      const nx = x + (dir === 'left' ? -1 : 1);
      if (!collide(nx, y, current)) {
        x = nx;
        play('move');
      }
      drawBoard();
    }

    function rotate() {
      if (!current) return;
      const rotated = current[0].map((_, i) => current.map(r => r[i]).reverse());
      if (!collide(x, y, rotated)) {
        current = rotated;
        play('rotate');
      }
      drawBoard();
    }

    function drop() {
      if (!current) return;
      const ny = y + 1;
      if (!collide(x, ny, current)) {
        y = ny;
      } else {
        merge();
        play('drop');
        clearLines().then(spawn);
      }
      drawBoard();
    }

    function tick() {
      drop();
    }

    function startGame() {
      document.getElementById('menu').style.display = 'none';
      document.getElementById('gameOver').style.display = 'none';
      for (let r = 0; r < ROWS; r++) board[r].fill(0);
      spawn();
      drawBoard();
      clearInterval(gameInterval);
      gameInterval = setInterval(tick, 500);
    }

    function endGame() {
      clearInterval(gameInterval);
      play('gameover');
      document.getElementById('gameOver').style.display = 'block';
    }

    document.getElementById('startBtn').onclick = startGame;
    document.getElementById('restartBtn').onclick = startGame;
  </script>
</body>
</html>
