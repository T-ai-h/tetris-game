<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Tetris Mobile Game</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<style>
  body {
    margin: 0;
    font-family: 'Press Start 2P', cursive;
    background: linear-gradient(to bottom, #1a1a1a, #000); /* พื้นหลังไล่เฉด */
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    padding: 10px; /* ลด padding เล็กลง */
    box-sizing: border-box;
    overflow: hidden; /* ป้องกันการ scroll โดยไม่ตั้งใจ */
  }

  h1 {
    text-shadow: 3px 3px 0px rgba(0,0,0,0.5); /* เงาชัดเจนขึ้น */
    color: #fff;
    letter-spacing: 2px;
    margin-top: 15px; /* ลด margin บน */
    margin-bottom: 10px;
    font-size: 6vw; /* ปรับขนาดตาม viewport */
  }

  /* --- Utility Class --- */
  .hidden {
    display: none !important;
  }

  /* --- Menu & Game Over Screens --- */
  #menuScreen, #gameOverlay {
    text-align: center;
    margin-top: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 15px;
    background-color: rgba(0, 0, 0, 0.7); /* พื้นหลังโปร่งใสเล็กน้อย */
    border-radius: 8px;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.5); /* เงาสีฟ้าเรืองแสง */
  }

  #gameOverlay div {
    margin-bottom: 15px;
    font-size: 1.2em;
    color: #ff4d4d; /* สีแดงสด */
    text-shadow: 1px 1px 0px #800;
  }

  /* --- Top UI (Score, Level, Next Piece) --- */
  #topUI {
    display: flex;
    flex-direction: row;
    align-items: flex-end;
    justify-content: space-around;
    gap: 10px;
    margin: 10px 0;
    width: 100%;
    max-width: 300px; /* ลดขนาด max-width */
    padding: 8px;
    box-sizing: border-box;
  }

  #scoreLevel {
    font-size: 12px;
    line-height: 1.4;
    text-align: left;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 8px 10px;
    border-radius: 6px;
    border: 2px solid #555;
    box-shadow: inset 0 0 4px rgba(255, 255, 255, 0.2);
    min-width: 90px;
  }

  #next {
    background-color: #222;
    border: 2px solid #777;
    width: 70px; /* ขนาดเล็กลง */
    height: 70px;
    box-shadow: 0 0 8px rgba(0, 255, 255, 0.3), inset 0 0 6px rgba(255, 255, 255, 0.1);
    border-radius: 4px;
  }

  /* --- Game Canvas --- */
  #gameContainer {
    display: block;
    border: 3px solid #fff;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
    background-color: #0d0d0d;
    border-radius: 6px;
    overflow: hidden;
    margin-top: 10px;
  }

  #game {
    background-color: #1a1a1a;
  }

  /* --- Controls --- */
  #controls {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, auto);
    gap: 1.5vw; /* เปลี่ยนเป็น vw */
    margin-top: 15px;
    padding: 10px;
    max-width: 75vw; /* จำกัดความกว้างด้วย vw */
    box-sizing: border-box;
  }

  #controls button, #menuScreen button, #gameOverlay button {
    width: 100%;
    height: 15vw; /* เปลี่ยนเป็น vw */
    font-family: 'Press Start 2P', cursive;
    font-size: 4vw; /* เปลี่ยนเป็น vw */
    background-color: #007bff;
    color: #fff;
    border: none;
    border-radius: 6px;
    box-shadow: 0 0.8vw 0px #0056b3;
    cursor: pointer;
    transition: all 0.1s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    text-shadow: 0.2vw 0.2vw 0px rgba(0,0,0,0.3);
    box-sizing: border-box;
  }

  #controls button:active, #menuScreen button:active, #gameOverlay button:active {
    background-color: #0056b3;
    transform: translateY(0.3vw);
    box-shadow: 0 0.2vw 0px #003f8e;
  }

  /* Grid Area สำหรับปุ่มควบคุม */
  #pauseBtn, #resumeBtn {
    grid-column: 1;
    grid-row: 1;
  }
  #rotateBtn {
    grid-column: 2;
    grid-row: 1;
  }
  #hardDropBtn {
    grid-column: 3;
    grid-row: 1;
  }
  #leftBtn {
    grid-column: 1;
    grid-row: 2;
  }
  #downBtn {
    grid-column: 2;
    grid-row: 2;
  }
  #rightBtn {
    grid-column: 3;
    grid-row: 2;
  }

  /* Responsive Adjustments */
  @media (max-width: 400px) { /* ปรับเมื่อหน้าจอกว้างน้อยกว่า 400px */
    h1 {
      font-size: 8vw; /* ปรับให้เล็กลงอีก */
      margin-top: 8px;
      margin-bottom: 5px;
    }
    #topUI {
      max-width: 90%; /* ขยายออกเล็กน้อย */
      gap: 1.5vw;
      margin: 8px 0;
      padding: 6px;
    }
    #scoreLevel {
      font-size: 3.5vw; /* ปรับตาม vw */
      padding: 6px 8px;
      min-width: unset; /* ให้ปรับตามเนื้อหา */
    }
    #next {
      width: 15vw; /* ปรับตาม vw */
      height: 15vw; /* ปรับตาม vw */
    }
    #gameContainer {
      width: 80vw; /* ปรับตาม vw */
      height: 160vw; /* ปรับตาม vw (สูง 2 เท่าของกว้าง) */
      border-width: 2px; /* ขอบบางลงอีก */
      margin-top: 8px;
    }
    #game {
      width: 100%;
      height: 100%;
    }
    #controls {
      gap: 2vw; /* เพิ่มช่องว่างเล็กน้อย */
      padding: 8px;
      max-width: 95vw; /* เพิ่ม max-width เพื่อให้ปุ่มใหญ่ขึ้น */
      margin-top: 10px;
    }
    #controls button, #menuScreen button, #gameOverlay button {
      height: 16vw; /* ปรับขนาดปุ่มให้ใหญ่ขึ้นเล็กน้อย */
      font-size: 4.5vw; /* ปรับขนาดตัวอักษร */
      box-shadow: 0 1vw 0px #0056b3;
    }
    #controls button:active, #menuScreen button:active, #gameOverlay button:active {
      transform: translateY(0.5vw);
      box-shadow: 0 0.3vw 0px #003f8e;
    }
    #menuScreen, #gameOverlay {
      padding: 10px;
      margin-top: 10px;
    }
    #gameOverlay div {
      font-size: 1.1em;
      margin-bottom: 10px;
    }
    #menuScreen button, #gameOverlay button {
      height: 12vw;
      font-size: 4vw;
    }
  }

  @media (max-width: 320px) { /* สำหรับหน้าจอที่เล็กมากๆ เช่น iPhone SE (รุ่นแรก) */
    h1 {
      font-size: 9vw;
    }
    #topUI {
      flex-direction: column; /* บนจอเล็กมากให้ stack กัน */
      align-items: center;
      max-width: 95%;
      gap: 5px;
    }
    #scoreLevel {
      margin-bottom: 5px;
      text-align: center;
      font-size: 4vw;
      padding: 5px 7px;
    }
    #next {
      width: 18vw;
      height: 18vw;
    }
    #gameContainer {
      width: 85vw; /* เพิ่มความกว้างขึ้นอีก */
      height: 170vw; /* เพิ่มความสูงตามสัดส่วน */
    }
    #controls {
      gap: 2.5vw;
      padding: 5px;
      max-width: 98vw; /* ขยายเกือบเต็มจอ */
      margin-top: 8px;
    }
    #controls button, #menuScreen button, #gameOverlay button {
      height: 18vw; /* ปรับขนาดปุ่มให้ใหญ่ขึ้นอีก */
      font-size: 5vw; /* ปรับขนาดตัวอักษร */
    }
  }

</style>
</head>
<body>

<div id="menuScreen">
  <h1>TETRIS MOBILE</h1>
  <button id="startBtn">เริ่มเล่น</button>
</div>

<div id="gameOverlay" class="hidden">
  <div>เกมจบ!</div>
  <div>คะแนนสุดท้าย: <span id="finalScore">0</span></div>
  <button id="restartBtn">เล่นใหม่</button>
</div>

<div id="topUI" class="hidden">
  <div id="scoreLevel">
    <div>คะแนน: <span id="score">0</span></div>
    <div>ระดับ: <span id="level">1</span></div>
  </div>
  <canvas id="next" width="90" height="90"></canvas>
</div>

<div id="gameContainer" class="hidden">
  <canvas id="game" width="300" height="600"></canvas>
</div>

<div id="controls" class="hidden">
  <button id="pauseBtn" title="Pause" aria-label="Pause">⏸️</button>
  <button id="rotateBtn">⟳</button>
  <button id="hardDropBtn">⚡</button>
  <button id="leftBtn">←</button>
  <button id="downBtn">↓</button>
  <button id="rightBtn">→</button>
  <button id="resumeBtn" title="Play" aria-label="Play" class="hidden">▶️</button>
</div>

<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const finalScoreEl = document.getElementById('finalScore');
  const menuScreen = document.getElementById('menuScreen');
  const gameOverlay = document.getElementById('gameOverlay');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const topUIDiv = document.getElementById('topUI');
  const gameContainer = document.getElementById('gameContainer');
  const controls = document.getElementById('controls');
  const hardDropBtn = document.getElementById('hardDropBtn');

  // Adjust canvas dimensions based on BLOCK_SIZE for responsiveness
  let BLOCK_SIZE;
  const COLS = 10;
  const ROWS = 20;

  function setCanvasDimensions() {
    const maxGameWidth = Math.min(300, window.innerWidth * 0.75); // Max 300px, but responsive
    BLOCK_SIZE = Math.floor(maxGameWidth / COLS);
    canvas.width = BLOCK_SIZE * COLS;
    canvas.height = BLOCK_SIZE * ROWS;
  }

  // Initial set and on resize
  setCanvasDimensions();
  window.addEventListener('resize', setCanvasDimensions);


  // ชนิดบล็อกและสี
  const SHAPES = [
    [],
    [[1,1,1,1]], // I
    [[1,1,0],[0,1,1]], // Z
    [[0,1,1],[1,1,0]], // S
    [[1,1,1],[0,1,0]], // T
    [[1,1],[1,1]], // O
    [[1,0,0],[1,1,1]], // L
    [[0,0,1],[1,1,1]], // J
  ];
  const COLORS = [
    null,
    '#00ffff', // I - Cyan
    '#ff0000', // Z - Red
    '#00ff00', // S - Green
    '#aa00ff', // T - Purple
    '#ffff00', // O - Yellow
    '#ff8800', // L - Orange
    '#0000ff', // J - Blue
  ];

  let board = [];
  let currentPiece = null;
  let nextPiece = null;
  let score = 0;
  let level = 1;
  let linesCleared = 0;
  let gameOver = false;
  let dropInterval = 1000;
  let lastDropTime = 0;
  let isPaused = false;
  let animationFrameId = null;

  function resetBoard() {
    board = [];
    for(let r=0; r<ROWS; r++) {
      board.push(new Array(COLS).fill(0));
    }
  }

  function randomPiece() {
    const id = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
    return {
      id: id,
      shape: SHAPES[id],
      color: COLORS[id],
      x: Math.floor(COLS/2) - Math.ceil(SHAPES[id][0].length/2),
      y: 0
    };
  }

  function drawBlock(x, y, color, context=ctx, alpha = 1) {
    context.fillStyle = color;
    context.globalAlpha = alpha;
    context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    context.strokeStyle = 'rgba(255,255,255,0.15)'; /* ขอบบล็อก */
    context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    context.globalAlpha = 1;
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        if(board[r][c]) {
          drawBlock(c, r, COLORS[board[r][c]]);
        }
      }
    }
  }

  function drawPiece(piece, context=ctx, alpha = 1) {
    piece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value) {
          drawBlock(piece.x + x, piece.y + y, piece.color, context, alpha);
        }
      });
    });
  }

  function drawNextPiece() {
    nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    if(!nextPiece) return;

    // คำนวณ offset เพื่อจัดตำแหน่งบล็อกให้อยู่ตรงกลาง nextCanvas
    const pieceWidth = nextPiece.shape[0].length;
    const pieceHeight = nextPiece.shape.length;
    const blockSizeNext = nextCanvas.width / 4; // ขนาดบล็อกใน nextCanvas (เพื่อให้พอดี 4x4)

    let startX = (nextCanvas.width - pieceWidth * blockSizeNext) / 2;
    let startY = (nextCanvas.height - pieceHeight * blockSizeNext) / 2;

    nextPiece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value) {
          nextCtx.fillStyle = nextPiece.color;
          nextCtx.fillRect(startX + x * blockSizeNext, startY + y * blockSizeNext, blockSizeNext - 2, blockSizeNext - 2);
          nextCtx.strokeStyle = 'rgba(255,255,255,0.2)';
          nextCtx.strokeRect(startX + x * blockSizeNext, startY + y * blockSizeNext, blockSizeNext - 2, blockSizeNext - 2);
        }
      });
    });
  }

  function collides(piece, board, offsetX, offsetY) {
    for(let y=0; y < piece.shape.length; y++) {
      for(let x=0; x < piece.shape[y].length; x++) {
        if(piece.shape[y][x]) {
          const newX = piece.x + x + offsetX;
          const newY = piece.y + y + offsetY;
          if(newX < 0 || newX >= COLS || newY >= ROWS) return true;
          if(newY >= 0 && board[newY][newX]) return true;
        }
      }
    }
    return false;
  }

  function mergePiece(piece, board) {
    piece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value && piece.y + y >= 0) {
          board[piece.y + y][piece.x + x] = piece.id;
        }
      });
    });
  }

  function rotate(piece) {
    const newShape = [];
    const rows = piece.shape.length;
    const cols = piece.shape[0].length;
    for(let x=0; x<cols; x++) {
      newShape[x] = [];
      for(let y=rows-1; y>=0; y--) {
        newShape[x][rows - 1 - y] = piece.shape[y][x];
      }
    }
    return newShape;
  }

  function rotatePiece() {
    if(isPaused || gameOver) return;
    const rotatedShape = rotate(currentPiece);
    const originalShape = currentPiece.shape;
    currentPiece.shape = rotatedShape;

    // Wall Kick - ตรวจสอบการชนและพยายามขยับเล็กน้อย
    const kicks = [
        [0, 0], // No kick
        [-1, 0], // Kick left
        [1, 0],  // Kick right
        [0, -1], // Kick up
        [-2, 0], // Double kick left
        [2, 0]   // Double kick right
    ];

    let rotatedSuccessfully = false;
    for (let i = 0; i < kicks.length; i++) {
        const [offsetX, offsetY] = kicks[i];
        if (!collides(currentPiece, board, offsetX, offsetY)) {
            currentPiece.x += offsetX;
            currentPiece.y += offsetY;
            rotatedSuccessfully = true;
            break;
        }
    }

    if (!rotatedSuccessfully) {
        currentPiece.shape = originalShape; // Revert if all kicks fail
        playSound('fail');
    } else {
        playSound('rotate');
    }
    draw();
  }

  function movePiece(offsetX, offsetY) {
    if(isPaused || gameOver) return;
    if(!collides(currentPiece, board, offsetX, offsetY)) {
      currentPiece.x += offsetX;
      currentPiece.y += offsetY;
      if (offsetY === 1) playSound('down');
      else if (offsetX !== 0) playSound('move');
      draw();
      return true;
    } else {
      if(offsetY === 1) { // If piece hits bottom or other blocks
        lockPiece();
      }
      return false;
    }
  }

  function hardDrop() {
    if(isPaused || gameOver) return;
    let linesDropped = 0;
    while (!collides(currentPiece, board, 0, 1)) {
      currentPiece.y++;
      linesDropped++;
    }
    score += linesDropped * 2; // Score for hard drop
    lockPiece();
    playSound('harddrop');
    draw();
  }

  function lockPiece() {
    mergePiece(currentPiece, board);
    clearLines();
    spawnNextPiece();
    if(collides(currentPiece, board, 0, 0)) {
      gameOver = true;
      showGameOver();
      playSound('gameover');
    } else {
      playSound('lock');
    }
  }

  function clearLines() {
    let lines = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (!board[y][x]) continue outer;
      }
      board.splice(y, 1);
      board.unshift(new Array(COLS).fill(0));
      lines++;
      y++;
    }

    if (lines > 0) {
      linesCleared += lines;
      // Score based on multiple lines cleared
      switch (lines) {
        case 1: score += 100 * level; break;
        case 2: score += 300 * level; break;
        case 3: score += 500 * level; break;
        case 4: score += 800 * level; break; // Tetris
      }

      const newLevel = Math.floor(linesCleared / 10) + 1;
      if (newLevel !== level) {
        level = newLevel;
        dropInterval = Math.max(50, 1000 - (level - 1) * 70); // Min drop interval 50ms
      }

      scoreEl.textContent = score;
      levelEl.textContent = level;
      playSound('clear');
    }
  }

  function getGhostPiece() {
    const ghost = { ...currentPiece };
    while (!collides(ghost, board, 0, 1)) {
      ghost.y++;
    }
    return ghost;
  }

  function spawnNextPiece() {
    currentPiece = nextPiece;
    currentPiece.x = Math.floor(COLS/2) - Math.ceil(currentPiece.shape[0].length/2);
    currentPiece.y = 0;
    nextPiece = randomPiece();
    drawNextPiece();
  }

  function updateScoreLevel() {
    scoreEl.textContent = score;
    levelEl.textContent = level;
  }

  function draw() {
    drawBoard();
    if (!gameOver && !isPaused) {
      const ghostPiece = getGhostPiece();
      drawPiece(ghostPiece, ctx, 0.2); // Draw ghost piece with transparency
      drawPiece(currentPiece);
    }
  }

  function gameLoop(timestamp) {
    if(gameOver || isPaused) {
      animationFrameId = requestAnimationFrame(gameLoop);
      return;
    }
    if(!lastDropTime) lastDropTime = timestamp;
    const delta = timestamp - lastDropTime;
    if(delta > dropInterval) {
      movePiece(0,1);
      lastDropTime = timestamp;
    }
    draw();
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  function preloadSounds() {
    for (const key in sounds) {
      if (sounds[key].src) {
        sounds[key].load();
      }
    }
  }

  function startGame() {
    setCanvasDimensions(); // Set canvas dimensions before starting game
    resetBoard();
    score = 0;
    level = 1;
    linesCleared = 0;
    dropInterval = 1000;
    lastDropTime = 0;
    gameOver = false;
    isPaused = false;
    currentPiece = randomPiece();
    nextPiece = randomPiece();
    drawNextPiece();
    updateScoreLevel();
    
    // Hide menu, show game elements
    menuScreen.classList.add('hidden');
    gameOverlay.classList.add('hidden');
    topUIDiv.classList.remove('hidden');
    gameContainer.classList.remove('hidden');
    controls.classList.remove('hidden');
    pauseBtn.classList.remove('hidden');
    resumeBtn.classList.add('hidden');

    preloadSounds();
    animationFrameId = requestAnimationFrame(gameLoop);
    playSound('start');
  }

  function showGameOver() {
    gameOverlay.classList.remove('hidden');
    finalScoreEl.textContent = score;
  }

  function pauseGame() {
    if(gameOver) return;
    isPaused = true;
    pauseBtn.classList.add('hidden');
    resumeBtn.classList.remove('hidden');
    playSound('pause');
  }

  function resumeGame() {
    if(gameOver) return;
    isPaused = false;
    lastDropTime = performance.now();
    pauseBtn.classList.remove('hidden');
    resumeBtn.classList.add('hidden');
    playSound('resume');
    requestAnimationFrame(gameLoop); // Restart animation frame
  }

  // Sound files (ensure these files exist in a 'sounds/' folder)
  const sounds = {
    move: new Audio('sounds/move.wav'),
    rotate: new Audio('sounds/rotate.wav'),
    down: new Audio('sounds/down.wav'),
    clear: new Audio('sounds/clear.wav'),
    fail: new Audio('sounds/fail.wav'),
    start: new Audio('sounds/start.wav'),
    pause: new Audio('sounds/pause.wav'),
    resume: new Audio('sounds/resume.wav'),
    gameover: new Audio('sounds/gameover.wav'),
    harddrop: new Audio('sounds/harddrop.wav'),
    lock: new Audio('sounds/lock.wav'),
  };

  function playSound(name) {
    const sound = sounds[name];
    if(sound) {
      // Clone node to allow overlapping playback for rapid actions (e.g., fast down moves)
      const clonedSound = sound.cloneNode();
      clonedSound.volume = 0.7; // Reduce volume slightly if sounds are too loud
      clonedSound.play().catch(e => console.log("Sound playback failed for", name, ":", e));
    }
  }

  // Event listeners for touch controls
  startBtn.addEventListener('click', startGame);
  restartBtn.addEventListener('click', () => {
    gameOverlay.classList.add('hidden');
    startGame();
  });

  pauseBtn.addEventListener('click', pauseGame);
  resumeBtn.addEventListener('click', resumeGame);

  document.getElementById('leftBtn').addEventListener('click', () => movePiece(-1,0));
  document.getElementById('rightBtn').addEventListener('click', () => movePiece(1,0));
  document.getElementById('rotateBtn').addEventListener('click', rotatePiece);
  document.getElementById('downBtn').addEventListener('click', () => movePiece(0,1));
  hardDropBtn.addEventListener('click', hardDrop);

  // Prevent scrolling on mobile when interacting with controls
  window.addEventListener('touchmove', function(e){
    // Only prevent default if the touch is within the game container or controls
    if(gameContainer.contains(e.target) || controls.contains(e.target)) {
      e.preventDefault();
    }
  }, { passive:false });

  // Initial setup: Ensure menu screen is visible at start, others are hidden
  document.addEventListener('DOMContentLoaded', () => {
    menuScreen.classList.remove('hidden');
    gameOverlay.classList.add('hidden');
    topUIDiv.classList.add('hidden');
    gameContainer.classList.add('hidden');
    controls.classList.add('hidden');
    setCanvasDimensions(); // Set initial canvas size on load
  });

</script>
</body>
</html>