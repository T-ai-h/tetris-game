<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Tetris Mobile Game</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<style>
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 0;
    background: linear-gradient(135deg, #3f51b5, #9c27b0);
    color: #eee;
    font-family: 'Press Start 2P', cursive, monospace;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    user-select: none;
  }
  #menuScreen, #gameOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 999;
    text-shadow: 0 0 10px #fff;
  }
  #menuScreen h1 {
    font-size: 2.8em;
    color: #ff4081;
    margin-bottom: 40px;
    text-shadow:
      0 0 10px #ff4081,
      0 0 20px #e040fb,
      0 0 30px #7c4dff;
  }
  button {
    font-family: 'Press Start 2P', cursive, monospace;
    cursor: pointer;
    border: none;
    border-radius: 15px;
    padding: 20px 40px;
    font-size: 1em;
    color: #fff;
    background: linear-gradient(45deg, #ff4081, #7c4dff);
    box-shadow:
      0 0 15px #ff4081,
      0 0 30px #7c4dff;
    transition: all 0.3s ease;
    user-select: none;
  }
  button:hover {
    background: linear-gradient(45deg, #e040fb, #651fff);
    box-shadow:
      0 0 20px #e040fb,
      0 0 40px #651fff;
    transform: scale(1.05);
  }
  button:active {
    transform: scale(0.95);
    box-shadow: none;
  }
  #scoreLevel {
    margin: 12px 0;
    font-size: 1.2em;
    text-align: center;
    text-shadow: 0 0 8px #fff;
  }
  #gameContainer {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: 12px;
    width: 100%;
    max-width: 460px;
    padding: 10px;
    background: rgba(0,0,0,0.3);
    border-radius: 15px;
    box-shadow:
      0 0 15px #7c4dff,
      inset 0 0 20px #e040fb;
  }
  canvas {
    image-rendering: pixelated;
    background: #111;
    border-radius: 12px;
    border: 4px solid transparent;
    box-shadow:
      0 0 15px #7c4dff,
      inset 0 0 40px #e040fb;
  }
  #game {
    width: 300px;
    height: 600px;
  }
  #next {
    width: 140px;
    height: 140px;
    margin-top: 40px;
  }
  #controls {
    display: flex;
    justify-content: center;
    gap: 15px;
    padding: 12px 10px;
    flex-wrap: wrap;
    width: 100%;
    max-width: 460px;
    margin-top: 15px;
  }
  #controls button {
    flex: 1 1 60px;
    padding: 18px 0;
    font-size: 1.4em;
    border-radius: 12px;
    background: linear-gradient(135deg, #651fff, #d500f9);
    box-shadow:
      0 0 15px #d500f9,
      inset 0 0 10px #651fff;
    transition: all 0.3s ease;
    max-width: 80px;
    color: #fff;
    user-select: none;
  }
  #controls button:active {
    background: linear-gradient(135deg, #d500f9, #651fff);
    box-shadow: none;
    transform: scale(0.9);
  }
  #pauseBtn, #resumeBtn {
    max-width: 120px;
    font-size: 1.1em;
    background: linear-gradient(135deg, #ff1744, #f50057);
    box-shadow:
      0 0 20px #f50057,
      inset 0 0 15px #ff1744;
    margin-left: 10px;
  }
  #pauseBtn:hover, #resumeBtn:hover {
    background: linear-gradient(135deg, #f50057, #c51162);
    box-shadow:
      0 0 25px #c51162,
      inset 0 0 20px #f50057;
  }
  #gameOverlay div {
    color: #ff1744;
    font-size: 3em;
    text-shadow:
      0 0 10px #ff1744,
      0 0 20px #f50057;
    margin-bottom: 30px;
  }
  @media (max-width: 400px) {
    #game { width: 240px; height: 480px; }
    #next { width: 110px; height: 110px; margin-top: 30px; }
    #controls button { font-size: 1.2em; max-width: 65px; padding: 15px 0; }
    #pauseBtn, #resumeBtn { max-width: 100px; font-size: 1em; margin-left: 5px;}
  }
</style>
</head>
<body>

<div id="menuScreen">
  <h1>TETRIS MOBILE</h1>
  <button id="startBtn">เริ่มเล่น</button>
</div>

<div id="gameOverlay" style="display:none;">
  <div>เกมจบ!</div>
  <button id="restartBtn">เล่นใหม่</button>
</div>

<div id="scoreLevel" style="display:none;">
  คะแนน: <span id="score">0</span> | ระดับ: <span id="level">1</span>
</div>

<div id="gameContainer" style="display:none;">
  <canvas id="game" width="300" height="600"></canvas>
  <canvas id="next" width="140" height="140"></canvas>
</div>

<div id="controls" style="display:none;">
  <button id="leftBtn">←</button>
  <button id="rightBtn">→</button>
  <button id="rotateBtn">⟳</button>
  <button id="downBtn">↓</button>
  <button id="pauseBtn">หยุดชั่วคราว</button>
  <button id="resumeBtn" style="display:none;">เล่นต่อ</button>
</div>

<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const menuScreen = document.getElementById('menuScreen');
  const gameOverlay = document.getElementById('gameOverlay');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const rotateBtn = document.getElementById('rotateBtn');
  const downBtn = document.getElementById('downBtn');
  const scoreLevel = document.getElementById('scoreLevel');
  const gameContainer = document.getElementById('gameContainer');
  const controls = document.getElementById('controls');

  const ROWS = 20;
  const COLS = 10;
  const BLOCK_SIZE = 30;
  canvas.width = COLS * BLOCK_SIZE;
  canvas.height = ROWS * BLOCK_SIZE;
  nextCanvas.width = 5 * BLOCK_SIZE;
  nextCanvas.height = 5 * BLOCK_SIZE;

  const colors = [
    null,
    '#FF3D67', // I - pink/red
    '#3DFF67', // S - green
    '#3D67FF', // Z - blue
    '#FF963D', // L - orange
    '#963DFF', // J - purple
    '#FFD93D', // O - yellow
    '#3DFFD9'  // T - cyan
  ];

  const pieces = {
    I: [
      [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]
    ],
    J: [
      [[2,0,0],[2,2,2],[0,0,0]],
      [[0,2,2],[0,2,0],[0,2,0]],
      [[0,0,0],[2,2,2],[0,0,2]],
      [[0,2,0],[0,2,0],[2,2,0]]
    ],
    L: [
      [[0,0,3],[3,3,3],[0,0,0]],
      [[0,3,0],[0,3,0],[0,3,3]],
      [[0,0,0],[3,3,3],[3,0,0]],
      [[3,3,0],[0,3,0],[0,3,0]]
    ],
    O: [
      [[4,4],[4,4]]
    ],
    S: [
      [[0,5,5],[5,5,0],[0,0,0]],
      [[0,5,0],[0,5,5],[0,0,5]]
    ],
    T: [
      [[0,6,0],[6,6,6],[0,0,0]],
      [[0,6,0],[0,6,6],[0,6,0]],
      [[0,0,0],[6,6,6],[0,6,0]],
      [[0,6,0],[6,6,0],[0,6,0]]
    ],
    Z: [
      [[7,7,0],[0,7,7],[0,0,0]],
      [[0,0,7],[0,7,7],[0,7,0]]
    ]
  };

  function createMatrix(w,h) {
    const matrix = [];
    for(let i=0; i<h; i++) {
      matrix.push(new Array(w).fill(0));
    }
    return matrix;
  }

  function drawMatrix(matrix, offset, context) {
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    for(let y=0; y < matrix.length; y++) {
      for(let x=0; x < matrix[y].length; x++) {
        const val = matrix[y][x];
        if(val !== 0) {
          context.fillStyle = colors[val];
          context.fillRect((x+offset.x)*BLOCK_SIZE, (y+offset.y)*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          context.strokeStyle = "#222";
          context.lineWidth = 2;
          context.strokeRect((x+offset.x)*BLOCK_SIZE, (y+offset.y)*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      }
    }
  }

  function rotate(matrix, dir) {
    // Rotate matrix clockwise or counterclockwise
    for(let y=0; y<matrix.length; y++) {
      for(let x=0; x<y; x++) {
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if(dir > 0) {
      matrix.forEach(row => row.reverse());
    } else {
      matrix.reverse();
    }
  }

  function randomPiece() {
    const keys = Object.keys(pieces);
    const key = keys[Math.floor(Math.random()*keys.length)];
    const shape = pieces[key];
    return {
      name: key,
      shape: shape[0],
      rotationIndex: 0,
      rotations: shape
    };
  }

  function collide(arena, player) {
    const m = player.shape;
    const o = player.pos;
    for(let y=0; y<m.length; y++) {
      for(let x=0; x<m[y].length; x++) {
        if(m[y][x] !== 0 &&
          (arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  function merge(arena, player) {
    player.shape.forEach((row,y) => {
      row.forEach((val,x) => {
        if(val !== 0) {
          arena[y+player.pos.y][x+player.pos.x] = val;
        }
      });
    });
  }

  let arena = createMatrix(COLS, ROWS);

  let player = {
    pos: {x: 0, y: 0},
    shape: null,
    rotationIndex: 0,
    rotations: null
  };

  let next = null;
  let dropCounter = 0;
  let dropInterval = 800; // ms, will speed up by level
  let lastTime = 0;
  let score = 0;
  let level = 1;
  let linesCleared = 0;
  let gameOver = false;
  let paused = false;

  function resetPlayer() {
    player = next || randomPiece();
    next = randomPiece();
    player.pos.y = 0;
    player.pos.x = Math.floor(COLS/2 - Math.ceil(player.shape[0].length/2));
    player.rotationIndex = 0;
    player.rotations = pieces[player.name];
    if(collide(arena, player)) {
      gameOver = true;
      showGameOver();
    }
    drawNext();
  }

  function showGameOver() {
    gameOverlay.style.display = 'flex';
    controls.style.display = 'none';
  }

  function clearGameOver() {
    gameOverlay.style.display = 'none';
    controls.style.display = 'flex';
  }

  function arenaSweep() {
    let rowCount = 1;
    outer: for(let y=arena.length-1; y>=0; y--) {
      for(let x=0; x<arena[y].length; x++) {
        if(arena[y][x] === 0) {
          continue outer;
        }
      }

      // Row full -> remove row
      const row = arena.splice(y, 1)[0].fill(0);
      arena.unshift(row);
      y++; // stay at same y because shifted down

      score += rowCount * 10;
      linesCleared++;
      rowCount *= 2;
    }
    updateLevel();
    updateScoreLevel();
  }

  function updateLevel() {
    level = Math.floor(linesCleared / 10) + 1;
    dropInterval = Math.max(100, 800 - (level-1) * 70);
  }

  function updateScoreLevel() {
    scoreEl.textContent = score;
    levelEl.textContent = level;
  }

  function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawMatrix(arena, {x:0,y:0}, ctx);
    drawMatrix(player.shape, player.pos, ctx);
  }

  function drawNext() {
    nextCtx.fillStyle = '#111';
    nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
    const offset = {
      x: Math.floor((5 - next.shape[0].length) / 2),
      y: Math.floor((5 - next.shape.length) / 2)
    };
    drawMatrix(next.shape, offset, nextCtx);
  }

  function playerDrop() {
    player.pos.y++;
    if(collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      arenaSweep();
      resetPlayer();
      return true;
    }
    dropCounter = 0;
    return false;
  }

  function playerMove(dir) {
    player.pos.x += dir;
    if(collide(arena, player)) {
      player.pos.x -= dir;
    }
  }

  function playerRotate(dir) {
    const oldRotation = player.rotationIndex;
    player.rotationIndex = (player.rotationIndex + dir + player.rotations.length) % player.rotations.length;
    player.shape = player.rotations[player.rotationIndex];

    if(collide(arena, player)) {
      // Wall kick simple
      player.pos.x += 1;
      if(collide(arena, player)) {
        player.pos.x -= 2;
        if(collide(arena, player)) {
          // Revert
          player.pos.x += 1;
          player.rotationIndex = oldRotation;
          player.shape = player.rotations[player.rotationIndex];
        }
      }
    }
  }

  function update(time=0) {
    if(gameOver || paused) return;

    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;

    if(dropCounter > dropInterval) {
      playerDrop();
    }

    draw();
    requestAnimationFrame(update);
  }

  function startGame() {
    arena = createMatrix(COLS, ROWS);
    score = 0;
    linesCleared = 0;
    level = 1;
    gameOver = false;
    paused = false;
    dropInterval = 800;
    dropCounter = 0;
    lastTime = 0;

    menuScreen.style.display = 'none';
    gameOverlay.style.display = 'none';
    scoreLevel.style.display = 'block';
    gameContainer.style.display = 'flex';
    controls.style.display = 'flex';
    pauseBtn.style.display = 'inline-block';
    resumeBtn.style.display = 'none';

    next = randomPiece();
    resetPlayer();
    updateScoreLevel();
    clearGameOver();
    update();
  }

  startBtn.addEventListener('click', startGame);
  restartBtn.addEventListener('click', () => {
    startGame();
  });

  pauseBtn.addEventListener('click', () => {
    paused = true;
    pauseBtn.style.display = 'none';
    resumeBtn.style.display = 'inline-block';
  });

  resumeBtn.addEventListener('click', () => {
    paused = false;
    pauseBtn.style.display = 'inline-block';
    resumeBtn.style.display = 'none';
    lastTime = performance.now();
    update();
  });

  leftBtn.addEventListener('click', () => {
    if(!paused && !gameOver) playerMove(-1);
    draw();
  });
  rightBtn.addEventListener('click', () => {
    if(!paused && !gameOver) playerMove(1);
    draw();
  });
  rotateBtn.addEventListener('click', () => {
    if(!paused && !gameOver) playerRotate(1);
    draw();
  });
  downBtn.addEventListener('click', () => {
    if(!paused && !gameOver) playerDrop();
    draw();
  });

  // Keyboard support for desktop testing (optional)
  window.addEventListener('keydown', e => {
    if(gameOver || paused) return;
    if(e.key === 'ArrowLeft') {
      playerMove(-1);
      draw();
    } else if(e.key === 'ArrowRight') {
      playerMove(1);
      draw();
    } else if(e.key === 'ArrowDown') {
      playerDrop();
      draw();
    } else if(e.key === 'ArrowUp') {
      playerRotate(1);
      draw();
    }
  });
</script>

</body>
</html>
