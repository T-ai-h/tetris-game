<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tetris Mobile Friendly</title>
<style>
   #info {
  position: fixed;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  padding: 5px 15px;
  border-radius: 10px;
  font-size: 18px;
  z-index: 100;
}

 button {
  width: 50px;
  height: 50px;
  font-size: 24px;
  border-radius: 10px;
  border: none;
  background: #555;
  color: white;
  user-select: none;
  touch-action: manipulation;
}
button:active {
  background: #999;
}


 #controls {
  position: fixed;
  bottom: 10px;      /* ปรับระยะจากล่างจอ */
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  justify-content: center;
  gap: 10px;
  background: rgba(0,0,0,0.6); /* เพิ่มพื้นหลังเล็กน้อยเพื่อให้เห็นปุ่ม */
  padding: 5px 10px;
  border-radius: 10px;
  z-index: 100;
  max-width: 100vw;
  flex-wrap: nowrap; /* หรือ wrap ถ้าปุ่มเยอะ */
}

  /* ปิด scroll */
  html, body {
    margin: 0; padding: 0;
    overflow: hidden;
    height: 100%;
  }

  body {
    margin: 0; padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #222;
    color: white;
    font-family: sans-serif;
  }
 canvas#game {
  width: 100vw;
  /* ลบ max-width ออก */
  aspect-ratio: 1 / 1.5; /* หรือปรับตามชอบ */
  height: auto;
  background: #000;
  display: block;
  margin: 20px auto;
}


  canvas#next {
    width: 100px;
    height: 100px;
  }
  #info {
  position: fixed;
  top: 5px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.6);
  padding: 5px 15px;
  border-radius: 10px;
  z-index: 101;
  font-size: 16px;
  color: white;
  text-align: center;
}

  #controls {
  touch-action: none;  /* ปิด gesture พวก scroll/pinch */
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
  }
  button {
    width: 20vw; height: 20vw;
    max-width: 80px; max-height: 80px;
    font-size: 5vw;
    border-radius: 10px;
    border: none;
    background: #555;
    color: white;
    user-select: none;
    touch-action: manipulation;
  }
  button:active {
    background: #999;
  }
  #gameOverlay {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.8);
    color: white;
    font-size: 24px;
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10;
    flex-direction: column;
  }
  
</style>
</head>
<body>
<div id="info">Score: <span id="score">0</span> | Level: <span id="level">1</span></div>
<canvas id="game"></canvas>
<canvas id="next" width="120" height="120"></canvas>

<div id="controls">
  <button id="leftBtn">◀️</button>
  <button id="downBtn">⬇️</button>
  <button id="rightBtn">▶️</button>
  <button id="rotateBtn">⟳</button>
</div>

<div id="gameOverlay">
  <div>Game Over</div>
  <button id="restartBtn">Restart</button>
</div>

<div id="info">Score: <span id="score">0</span> | Level: <span id="level">1</span></div>

<script>
  const controls = document.getElementById("controls");
controls.addEventListener("touchmove", function(e) {
  e.preventDefault();  // ป้องกันเลื่อนหน้าเมื่อสัมผัสในโซนปุ่ม
}, { passive: false });

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const nextCanvas = document.getElementById("next");
const nextCtx = nextCanvas.getContext("2d");

const ROWS = 20;
const COLS = 10;
let BLOCK_SIZE = 30;
const NEXT_BLOCK_SIZE = 30;

let score = 0;
let level = 1;
const scoreEl = document.getElementById("score");
const levelEl = document.getElementById("level");

const gameOverlay = document.getElementById("gameOverlay");
const restartBtn = document.getElementById("restartBtn");

const colors = [
  null,
  "#00f0f0", "#0000f0", "#f0a000", "#f0f000",
  "#00f000", "#a000f0", "#f00000",
];

const tetrominoes = [
  [],
  [[1, 1, 1, 1]],
  [[2, 0, 0], [2, 2, 2]],
  [[0, 0, 3], [3, 3, 3]],
  [[4, 4], [4, 4]],
  [[0, 5, 5], [5, 5, 0]],
  [[0, 6, 0], [6, 6, 6]],
  [[7, 7, 0], [0, 7, 7]],
];

let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));

let currentPiece = null;
let currentX = 0;
let currentY = 0;
let nextPiece = null;

let dropSpeed = 700;
let gameInterval;

const leftBtn = document.getElementById("leftBtn");
const rightBtn = document.getElementById("rightBtn");
const downBtn = document.getElementById("downBtn");
const rotateBtn = document.getElementById("rotateBtn");

function randomPiece() {
  const id = Math.floor(Math.random() * (tetrominoes.length - 1)) + 1;
  return { id: id, shape: tetrominoes[id] };
}
function resizeCanvas() {
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  canvas.width = width;
  canvas.height = height;
  BLOCK_SIZE = width / COLS * 0.75;  // ลด block size ลง 75% ตัวอย่าง
}


function drawBlock(x, y, colorId, size = BLOCK_SIZE, context = ctx) {
  context.fillStyle = colors[colorId];
  context.fillRect(x * size, y * size, size, size);
  context.strokeStyle = "#222";
  context.lineWidth = 2;
  context.strokeRect(x * size, y * size, size, size);
}

function drawGrid() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (grid[r][c]) drawBlock(c, r, grid[r][c]);
    }
  }
}

function drawPiece(piece, x, y, context = ctx, size = BLOCK_SIZE) {
  piece.shape.forEach((row, dy) => {
    row.forEach((val, dx) => {
      if (val) drawBlock(x + dx, y + dy, piece.id, size, context);
    });
  });
}

function drawNextPiece() {
  nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
  const shape = nextPiece.shape;
  const offsetX = Math.floor((nextCanvas.width / NEXT_BLOCK_SIZE - shape[0].length) / 2);
  const offsetY = Math.floor((nextCanvas.height / NEXT_BLOCK_SIZE - shape.length) / 2);
  drawPiece(nextPiece, offsetX, offsetY, nextCtx, NEXT_BLOCK_SIZE);
}

function validMove(piece, x, y) {
  for (let r = 0; r < piece.shape.length; r++) {
    for (let c = 0; c < piece.shape[r].length; c++) {
      if (piece.shape[r][c]) {
        let newX = x + c;
        let newY = y + r;
        if (newX < 0 || newX >= COLS || newY >= ROWS) return false;
        if (newY >= 0 && grid[newY][newX]) return false;
      }
    }
  }
  return true;
}

function lockPiece(piece, x, y) {
  piece.shape.forEach((row, r) => {
    row.forEach((val, c) => {
      if (val && y + r >= 0) grid[y + r][x + c] = piece.id;
    });
  });
}

function clearLines() {
  let lines = 0;
  outer: for (let r = ROWS - 1; r >= 0; r--) {
    for (let c = 0; c < COLS; c++) {
      if (!grid[r][c]) continue outer;
    }
    grid.splice(r, 1);
    grid.unshift(Array(COLS).fill(0));
    lines++;
    r++;
  }
  if (lines > 0) {
    score += lines * 10;
    scoreEl.textContent = score;
    updateSpeed();
  }
}

function rotate(piece) {
  const oldShape = piece.shape;
  const rows = oldShape.length;
  const cols = oldShape[0].length;
  let newShape = [];
  for (let x = 0; x < cols; x++) {
    newShape[x] = [];
    for (let y = rows - 1; y >= 0; y--) {
      newShape[x][rows - 1 - y] = oldShape[y][x];
    }
  }
  return newShape;
}

function resetPiece() {
  currentPiece = nextPiece || randomPiece();
  nextPiece = randomPiece();
  drawNextPiece();
  currentX = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
  currentY = -1;
  if (!validMove(currentPiece, currentX, currentY)) gameOver();
}

function gameOver() {
  gameOverlay.style.display = "flex";
  clearInterval(gameInterval);
}

restartBtn.addEventListener("click", () => {
  gameOverlay.style.display = "none";
  grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
  score = 0; level = 1;
  scoreEl.textContent = score;
  levelEl.textContent = level;
  nextPiece = randomPiece();
  resetPiece();
  updateSpeed();
  draw();
});

let uiMoveInterval = null;

function startContinuousMove(direction) {
  if (gameOverlay.style.display === "flex") return;
  if (uiMoveInterval) return;
  handleMove(direction);
  uiMoveInterval = setInterval(() => handleMove(direction), 150);
}

function stopContinuousMove() {
  if (uiMoveInterval) {
    clearInterval(uiMoveInterval);
    uiMoveInterval = null;
  }
}

leftBtn.addEventListener("mousedown", () => startContinuousMove("left"));
leftBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startContinuousMove("left"); });
leftBtn.addEventListener("mouseup", stopContinuousMove);
leftBtn.addEventListener("mouseleave", stopContinuousMove);
leftBtn.addEventListener("touchend", stopContinuousMove);
leftBtn.addEventListener("touchcancel", stopContinuousMove);

rightBtn.addEventListener("mousedown", () => startContinuousMove("right"));
rightBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startContinuousMove("right"); });
rightBtn.addEventListener("mouseup", stopContinuousMove);
rightBtn.addEventListener("mouseleave", stopContinuousMove);
rightBtn.addEventListener("touchend", stopContinuousMove);
rightBtn.addEventListener("touchcancel", stopContinuousMove);

downBtn.addEventListener("mousedown", () => startContinuousMove("down"));
downBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startContinuousMove("down"); });
downBtn.addEventListener("mouseup", stopContinuousMove);
downBtn.addEventListener("mouseleave", stopContinuousMove);
downBtn.addEventListener("touchend", stopContinuousMove);
downBtn.addEventListener("touchcancel", stopContinuousMove);

rotateBtn.addEventListener("click", () => handleMove("rotate"));
rotateBtn.addEventListener("touchstart", (e) => { e.preventDefault(); handleMove("rotate"); });

function handleMove(direction) {
  if (gameOverlay.style.display === "flex") return;
  if (direction === "left" && validMove(currentPiece, currentX - 1, currentY)) currentX--;
  else if (direction === "right" && validMove(currentPiece, currentX + 1, currentY)) currentX++;
  else if (direction === "down") { update(); return; }
  else if (direction === "rotate") {
    const rotated = rotate(currentPiece);
    const test = { ...currentPiece, shape: rotated };
    if (validMove(test, currentX, currentY)) currentPiece.shape = rotated;
    else if (validMove(test, currentX - 1, currentY)) { currentX--; currentPiece.shape = rotated; }
    else if (validMove(test, currentX + 1, currentY)) { currentX++; currentPiece.shape = rotated; }
  }
  draw();
}

function update() {
  if (validMove(currentPiece, currentX, currentY + 1)) currentY++;
  else {
    lockPiece(currentPiece, currentX, currentY);
    clearLines();
    resetPiece();
  }
  draw();
}

function draw() {
  drawGrid();
  drawPiece(currentPiece, currentX, currentY);
}

function updateSpeed() {
  level = Math.floor(score / 50) + 1;
  levelEl.textContent = level;
  dropSpeed = Math.max(100, 700 - (level - 1) * 50);
  clearInterval(gameInterval);
  gameInterval = setInterval(update, dropSpeed);
  updateBackground();
}

function updateBackground() {
  const backgrounds = [
    "linear-gradient(135deg, #000000, #1a1a1a)",   // level 1: ดำเรียบ
    "linear-gradient(135deg, #004d4d, #009999)",   // level 2: เขียวฟ้า
    "linear-gradient(135deg, #00264d, #0059b3)",   // level 3: น้ำเงินเข้ม
    "linear-gradient(135deg, #33001a, #660033)",   // level 4: ม่วงแดง
    "linear-gradient(135deg, #331a00, #cc6600)",   // level 5: น้ำตาลส้ม
    "linear-gradient(135deg, #1a3300, #66cc00)",   // level 6: เขียวสด
    "linear-gradient(135deg, #4d004d, #990099)",   // level 7: ม่วงเจิดจ้า
    "linear-gradient(135deg, #003333, #00cccc)",   // level 8: ฟ้าน้ำทะเล
    "linear-gradient(135deg, #26004d, #9933ff)",   // level 9: ม่วงนีออน
    "linear-gradient(135deg, #0d0d0d, #333333)"    // level 10+: เทาเข้มคลาสสิก
  ];
  
  const bg = backgrounds[Math.min(level - 1, backgrounds.length - 1)];
  canvas.style.background = bg;
}


window.addEventListener('resize', () => {
  resizeCanvas();
  draw();
});

// ปิด scroll gesture (touchmove)
document.addEventListener('touchmove', function(e) {
  e.preventDefault();
}, { passive: false });

nextPiece = randomPiece();
resizeCanvas();
resetPiece();
updateSpeed();
draw();
</script>
</body>
</html>
