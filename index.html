<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Tetris Mobile Game</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<style>
  body {
    margin: 0;
    font-family: 'Press Start 2P', cursive;
    background: linear-gradient(to bottom, #1a1a1a, #000);
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    /* เปลี่ยน min-height เพื่อให้ยืดหยุ่นมากขึ้นตาม vh หรือ min(100vh, content-height) */
    min-height: 100vh;
    padding: 1.5vh 2vw; /* ใช้ vh และ vw สำหรับ padding */
    box-sizing: border-box; /* สำคัญมาก */
    overflow: hidden; /* ป้องกันการ scroll โดยไม่ตั้งใจ */
  }

  h1 {
    text-shadow: 3px 3px 0px rgba(0,0,0,0.5);
    color: #fff;
    letter-spacing: 2px;
    margin-top: 1vh; /* ปรับ margin ด้วย vh */
    margin-bottom: 1vh; /* ปรับ margin ด้วย vh */
    font-size: min(8vw, 6vh); /* ใช้ min เพื่อให้ขนาดเหมาะสมทั้งแนวกว้างและแนวสูง */
  }

  /* --- Utility Class --- */
  .hidden {
    display: none !important;
  }

  /* --- Menu & Game Over Screens --- */
  #menuScreen, #gameOverlay {
    text-align: center;
    margin-top: 2vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2.5vh 5vw; /* ปรับ padding ด้วย vh/vw */
    background-color: rgba(0, 0, 0, 0.7);
    border-radius: 8px;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
    max-width: 90vw; /* จำกัดความกว้าง */
    box-sizing: border-box;
  }

  #gameOverlay div {
    margin-bottom: 2vh;
    font-size: min(5vw, 4vh); /* ปรับขนาดตัวอักษร */
    color: #ff4d4d;
    text-shadow: 1px 1px 0px #800;
  }

  /* --- Top UI (Score, Level, Next Piece) --- */
  #topUI {
    display: flex;
    flex-direction: row;
    align-items: flex-end;
    justify-content: space-around;
    gap: 1.5vh; /* ปรับ gap ด้วย vh */
    margin: 1.5vh 0; /* ปรับ margin ด้วย vh */
    width: 100%;
    max-width: min(85vw, 400px); /* จำกัดความกว้างรวม */
    padding: 1.5vh 2vw;
    box-sizing: border-box;
  }

  #scoreLevel {
    font-size: min(4vw, 2.5vh); /* ปรับขนาดตัวอักษรด้วย min(vw, vh) */
    line-height: 1.4;
    text-align: left;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 1.5vh 2vw; /* ปรับ padding ด้วย vh/vw */
    border-radius: 6px;
    border: 2px solid #555;
    box-shadow: inset 0 0 4px rgba(255, 255, 255, 0.2);
    min-width: 25vw; /* กำหนด min-width ด้วย vw */
  }

  #next {
    background-color: #222;
    border: 2px solid #777;
    width: min(18vw, 80px); /* ปรับขนาดด้วย min(vw, px) */
    height: min(18vw, 80px); /* ปรับขนาดด้วย min(vw, px) */
    box-shadow: 0 0 8px rgba(0, 255, 255, 0.3), inset 0 0 6px rgba(255, 255, 255, 0.1);
    border-radius: 4px;
  }

  /* --- Game Canvas --- */
  #gameContainer {
    display: block;
    border: 3px solid #fff;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
    background-color: #0d0d0d;
    border-radius: 6px;
    overflow: hidden;
    margin-top: 1.5vh; /* ปรับ margin ด้วย vh */
    /* ขนาดของ Canvas จะถูกกำหนดด้วย JavaScript เพื่อให้แน่ใจว่าเป็นสัดส่วน 1:2 */
    max-width: 90vw; /* จำกัดสูงสุด */
    max-height: 80vh; /* จำกัดสูงสุด */
    box-sizing: border-box;
  }

  #game {
    background-color: #1a1a1a;
  }

  /* --- Controls --- */
  #controls {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(2, auto); /* เหลือ 2 แถวหลัก (ปุ่ม Hard Drop จะถูกรวม) */
    gap: 1.5vh; /* เปลี่ยนเป็น vh */
    margin-top: 2vh; /* ปรับ margin ด้วย vh */
    padding: 2vh 2vw; /* ปรับ padding ด้วย vh/vw */
    max-width: min(95vw, 400px); /* จำกัดความกว้างด้วย min(vw, px) */
    box-sizing: border-box;
  }

  #controls button, #menuScreen button, #gameOverlay button {
    width: 100%;
    height: min(15vw, 8vh); /* ใช้ min(vw, vh) เพื่อให้ขนาดปุ่มยืดหยุ่นและไม่ใหญ่เกินไป */
    font-family: 'Press Start 2P', cursive;
    font-size: min(4.5vw, 3vh); /* ใช้ min(vw, vh) */
    background-color: #007bff;
    color: #fff;
    border: none;
    border-radius: 6px;
    box-shadow: 0 0.8vw 0px #0056b3;
    cursor: pointer;
    transition: all 0.1s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    text-shadow: 0.2vw 0.2vw 0px rgba(0,0,0,0.3);
    box-sizing: border-box;
  }

  #controls button:active, #menuScreen button:active, #gameOverlay button:active {
    background-color: #0056b3;
    transform: translateY(0.3vw);
    box-shadow: 0 0.2vw 0px #003f8e;
  }

  /* Grid Area สำหรับปุ่มควบคุม */
  #pauseBtn, #resumeBtn {
    grid-column: 1;
    grid-row: 1;
  }
  #rotateBtn {
    grid-column: 2;
    grid-row: 1;
  }
  /* ทำให้ Hard Drop อยู่แถวเดียวกับปุ่มเลื่อนซ้ายขวา แต่เป็นปุ่มใหญ่ */
  #hardDropBtn {
    grid-column: 3;
    grid-row: 1;
  }
  #leftBtn {
    grid-column: 1;
    grid-row: 2;
  }
  #downBtn {
    grid-column: 2;
    grid-row: 2;
  }
  #rightBtn {
    grid-column: 3;
    grid-row: 2;
  }

  /* Responsive adjustments for extremely small screens or landscape mode */
  @media (max-height: 500px) and (orientation: landscape) {
    body {
        flex-direction: row; /* เปลี่ยนเป็นแนวนอน */
        justify-content: center;
        align-items: center;
        padding: 1vw 1vh;
    }
    h1 {
        display: none; /* ซ่อนชื่อเกมเมื่อเป็นแนวนอนและจอเล็ก */
    }
    #topUI {
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        margin: 0 1vw;
        max-width: unset;
        min-width: 100px;
        height: 100%;
    }
    #scoreLevel {
        margin-bottom: 1vh;
        font-size: min(2.5vw, 1.8vh);
        min-width: 80px;
        text-align: center;
    }
    #next {
        width: min(10vw, 10vh);
        height: min(10vw, 10vh);
        margin-top: 1vh;
    }
    #gameContainer {
        margin-top: 0;
        margin-left: 1vw;
        margin-right: 1vw;
        max-width: 50vw;
        max-height: 90vh; /* จำกัดความสูง */
    }
    #controls {
        grid-template-columns: repeat(2, 1fr); /* 2 คอลัมน์สำหรับแนวนอน */
        grid-template-rows: repeat(3, auto);
        gap: 1vw;
        margin-top: 0;
        margin-left: 1vw;
        padding: 1vw;
        max-width: 40vw; /* จำกัดความกว้าง */
        height: 90vh; /* ยืดเกือบเต็มความสูง */
    }
    #controls button {
        height: min(10vw, 15vh); /* ปรับขนาดปุ่มให้เหมาะกับแนวนอน */
        font-size: min(3.5vw, 4vh);
    }

    #pauseBtn, #resumeBtn { grid-column: 1; grid-row: 1; }
    #rotateBtn { grid-column: 2; grid-row: 1; }
    #hardDropBtn { grid-column: 1 / span 2; grid-row: 2; } /* Hard Drop เต็ม 2 คอลัมน์ */
    #leftBtn { grid-column: 1; grid-row: 3; }
    #downBtn { grid-column: 2; grid-row: 3; }
    #rightBtn { display: none; } /* ซ่อนปุ่มขวาเพื่อประหยัดพื้นที่ ถ้าจำเป็น */

    /* อาจจะรวมปุ่มเลื่อนซ้าย-ขวา-ลง เป็น 4 ทิศทางบนหน้าจอถ้าพื้นที่น้อยมาก */
  }

</style>
</head>
<body>

<div id="menuScreen">
  <h1>TETRIS MOBILE</h1>
  <button id="startBtn">เริ่มเล่น</button>
</div>

<div id="gameOverlay" class="hidden">
  <div>เกมจบ!</div>
  <div>คะแนนสุดท้าย: <span id="finalScore">0</span></div>
  <button id="restartBtn">เล่นใหม่</button>
</div>

<div id="topUI" class="hidden">
  <div id="scoreLevel">
    <div>คะแนน: <span id="score">0</span></div>
    <div>ระดับ: <span id="level">1</span></div>
  </div>
  <canvas id="next" width="90" height="90"></canvas>
</div>

<div id="gameContainer" class="hidden">
  <canvas id="game" width="300" height="600"></canvas>
</div>

<div id="controls" class="hidden">
  <button id="pauseBtn" title="Pause" aria-label="Pause">⏸️</button>
  <button id="rotateBtn">⟳</button>
  <button id="hardDropBtn">⚡</button>
  <button id="leftBtn">←</button>
  <button id="downBtn">↓</button>
  <button id="rightBtn">→</button>
  <button id="resumeBtn" title="Play" aria-label="Play" class="hidden">▶️</button>
</div>

<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const finalScoreEl = document.getElementById('finalScore');
  const menuScreen = document.getElementById('menuScreen');
  const gameOverlay = document.getElementById('gameOverlay');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const topUIDiv = document.getElementById('topUI');
  const gameContainer = document.getElementById('gameContainer');
  const controls = document.getElementById('controls');
  const hardDropBtn = document.getElementById('hardDropBtn');

  // Adjust canvas dimensions based on BLOCK_SIZE for responsiveness
  let BLOCK_SIZE;
  const COLS = 10;
  const ROWS = 20;

  function setCanvasDimensions() {
    // คำนวณขนาดของ canvas ให้สัมพันธ์กับ viewport height และ width
    // โดยพยายามรักษาสัดส่วน 1:2 (width:height)
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;

    let desiredCanvasWidth;
    let desiredCanvasHeight;

    // ถ้าเป็นแนวตั้ง (portrait)
    if (viewportHeight > viewportWidth) {
        desiredCanvasWidth = Math.min(300, viewportWidth * 0.85); // ให้ Canvas กว้างไม่เกิน 85% ของ viewport width, และไม่เกิน 300px
        desiredCanvasHeight = desiredCanvasWidth * 2; // รักษาสัดส่วน 1:2
    } else { // ถ้าเป็นแนวนอน (landscape)
        desiredCanvasHeight = Math.min(600, viewportHeight * 0.8); // ให้ Canvas สูงไม่เกิน 80% ของ viewport height, และไม่เกิน 600px
        desiredCanvasWidth = desiredCanvasHeight / 2; // รักษาสัดส่วน 1:2
    }
    
    BLOCK_SIZE = Math.floor(desiredCanvasWidth / COLS);
    canvas.width = BLOCK_SIZE * COLS;
    canvas.height = BLOCK_SIZE * ROWS;

    // ตั้งค่าขนาด container ให้เท่ากับ canvas
    gameContainer.style.width = canvas.width + 'px';
    gameContainer.style.height = canvas.height + 'px';
  }

  // Initial set and on resize
  setCanvasDimensions();
  window.addEventListener('resize', setCanvasDimensions);


  // ชนิดบล็อกและสี
  const SHAPES = [
    [],
    [[1,1,1,1]], // I
    [[1,1,0],[0,1,1]], // Z
    [[0,1,1],[1,1,0]], // S
    [[1,1,1],[0,1,0]], // T
    [[1,1],[1,1]], // O
    [[1,0,0],[1,1,1]], // L
    [[0,0,1],[1,1,1]], // J
  ];
  const COLORS = [
    null,
    '#00ffff', // I - Cyan
    '#ff0000', // Z - Red
    '#00ff00', // S - Green
    '#aa00ff', // T - Purple
    '#ffff00', // O - Yellow
    '#ff8800', // L - Orange
    '#0000ff', // J - Blue
  ];

  let board = [];
  let currentPiece = null;
  let nextPiece = null;
  let score = 0;
  let level = 1;
  let linesCleared = 0;
  let gameOver = false;
  let dropInterval = 1000;
  let lastDropTime = 0;
  let isPaused = false;
  let animationFrameId = null;

  function resetBoard() {
    board = [];
    for(let r=0; r<ROWS; r++) {
      board.push(new Array(COLS).fill(0));
    }
  }

  function randomPiece() {
    const id = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
    return {
      id: id,
      shape: SHAPES[id],
      color: COLORS[id],
      x: Math.floor(COLS/2) - Math.ceil(SHAPES[id][0].length/2),
      y: 0
    };
  }

  function drawBlock(x, y, color, context=ctx, alpha = 1) {
    context.fillStyle = color;
    context.globalAlpha = alpha;
    context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    context.strokeStyle = 'rgba(255,255,255,0.15)'; /* ขอบบล็อก */
    context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    context.globalAlpha = 1;
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        if(board[r][c]) {
          drawBlock(c, r, COLORS[board[r][c]]);
        }
      }
    }
  }

  function drawPiece(piece, context=ctx, alpha = 1) {
    piece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value) {
          drawBlock(piece.x + x, piece.y + y, piece.color, context, alpha);
        }
      });
    });
  }

  function drawNextPiece() {
    nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    if(!nextPiece) return;

    // คำนวณ offset เพื่อจัดตำแหน่งบล็อกให้อยู่ตรงกลาง nextCanvas
    const pieceWidth = nextPiece.shape[0].length;
    const pieceHeight = nextPiece.shape.length;
    const blockSizeNext = nextCanvas.width / 4; // ขนาดบล็อกใน nextCanvas (เพื่อให้พอดี 4x4)

    let startX = (nextCanvas.width - pieceWidth * blockSizeNext) / 2;
    let startY = (nextCanvas.height - pieceHeight * blockSizeNext) / 2;

    nextPiece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value) {
          nextCtx.fillStyle = nextPiece.color;
          nextCtx.fillRect(startX + x * blockSizeNext, startY + y * blockSizeNext, blockSizeNext - 2, blockSizeNext - 2);
          nextCtx.strokeStyle = 'rgba(255,255,255,0.2)';
          nextCtx.strokeRect(startX + x * blockSizeNext, startY + y * blockSizeNext, blockSizeNext - 2, blockSizeNext - 2);
        }
      });
    });
  }

  function collides(piece, board, offsetX, offsetY) {
    for(let y=0; y < piece.shape.length; y++) {
      for(let x=0; x < piece.shape[y].length; x++) {
        if(piece.shape[y][x]) {
          const newX = piece.x + x + offsetX;
          const newY = piece.y + y + offsetY;
          if(newX < 0 || newX >= COLS || newY >= ROWS) return true;
          if(newY >= 0 && board[newY][newX]) return true;
        }
      }
    }
    return false;
  }

  function mergePiece(piece, board) {
    piece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value && piece.y + y >= 0) {
          board[piece.y + y][piece.x + x] = piece.id;
        }
      });
    });
  }

  function rotate(piece) {
    const newShape = [];
    const rows = piece.shape.length;
    const cols = piece.shape[0].length;
    for(let x=0; x<cols; x++) {
      newShape[x] = [];
      for(let y=rows-1; y>=0; y--) {
        newShape[x][rows - 1 - y] = piece.shape[y][x];
      }
    }
    return newShape;
  }

  function rotatePiece() {
    if(isPaused || gameOver) return;
    const rotatedShape = rotate(currentPiece);
    const originalShape = currentPiece.shape;
    currentPiece.shape = rotatedShape;

    // Wall Kick - ตรวจสอบการชนและพยายามขยับเล็กน้อย
    const kicks = [
        [0, 0], // No kick
        [-1, 0], // Kick left
        [1, 0],  // Kick right
        [0, -1], // Kick up
        [-2, 0], // Double kick left
        [2, 0]   // Double kick right
    ];

    let rotatedSuccessfully = false;
    for (let i = 0; i < kicks.length; i++) {
        const [offsetX, offsetY] = kicks[i];
        if (!collides(currentPiece, board, offsetX, offsetY)) {
            currentPiece.x += offsetX;
            currentPiece.y += offsetY;
            rotatedSuccessfully = true;
            break;
        }
    }

    if (!rotatedSuccessfully) {
        currentPiece.shape = originalShape; // Revert if all kicks fail
        playSound('fail');
    } else {
        playSound('rotate');
    }
    draw();
  }

  function movePiece(offsetX, offsetY) {
    if(isPaused || gameOver) return;
    if(!collides(currentPiece, board, offsetX, offsetY)) {
      currentPiece.x += offsetX;
      currentPiece.y += offsetY;
      if (offsetY === 1) playSound('down');
      else if (offsetX !== 0) playSound('move');
      draw();
      return true;
    } else {
      if(offsetY === 1) { // If piece hits bottom or other blocks
        lockPiece();
      }
      return false;
    }
  }

  function hardDrop() {
    if(isPaused || gameOver) return;
    let linesDropped = 0;
    while (!collides(currentPiece, board, 0, 1)) {
      currentPiece.y++;
      linesDropped++;
    }
    score += linesDropped * 2; // Score for hard drop
    lockPiece();
    playSound('harddrop');
    draw();
  }

  function lockPiece() {
    mergePiece(currentPiece, board);
    clearLines();
    spawnNextPiece();
    if(collides(currentPiece, board, 0, 0)) {
      gameOver = true;
      showGameOver();
      playSound('gameover');
    } else {
      playSound('lock');
    }
  }

  function clearLines() {
    let lines = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (!board[y][x]) continue outer;
      }
      board.splice(y, 1);
      board.unshift(new Array(COLS).fill(0));
      lines++;
      y++;
    }

    if (lines > 0) {
      linesCleared += lines;
      // Score based on multiple lines cleared
      switch (lines) {
        case 1: score += 100 * level; break;
        case 2: score += 300 * level; break;
        case 3: score += 500 * level; break;
        case 4: score += 800 * level; break; // Tetris
      }

      const newLevel = Math.floor(linesCleared / 10) + 1;
      if (newLevel !== level) {
        level = newLevel;
        dropInterval = Math.max(50, 1000 - (level - 1) * 70); // Min drop interval 50ms
      }

      scoreEl.textContent = score;
      levelEl.textContent = level;
      playSound('clear');
    }
  }

  function getGhostPiece() {
    const ghost = { ...currentPiece };
    while (!collides(ghost, board, 0, 1)) {
      ghost.y++;
    }
    return ghost;
  }

  function spawnNextPiece() {
    currentPiece = nextPiece;
    currentPiece.x = Math.floor(COLS/2) - Math.ceil(currentPiece.shape[0].length/2);
    currentPiece.y = 0;
    nextPiece = randomPiece();
    drawNextPiece();
  }

  function updateScoreLevel() {
    scoreEl.textContent = score;
    levelEl.textContent = level;
  }

  function draw() {
    drawBoard();
    if (!gameOver && !isPaused) {
      const ghostPiece = getGhostPiece();
      drawPiece(ghostPiece, ctx, 0.2); // Draw ghost piece with transparency
      drawPiece(currentPiece);
    }
  }

  function gameLoop(timestamp) {
    if(gameOver || isPaused) {
      animationFrameId = requestAnimationFrame(gameLoop);
      return;
    }
    if(!lastDropTime) lastDropTime = timestamp;
    const delta = timestamp - lastDropTime;
    if(delta > dropInterval) {
      movePiece(0,1);
      lastDropTime = timestamp;
    }
    draw();
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  function preloadSounds() {
    for (const key in sounds) {
      if (sounds[key].src) {
        sounds[key].load();
      }
    }
  }

  function startGame() {
    setCanvasDimensions(); // Set canvas dimensions before starting game
    resetBoard();
    score = 0;
    level = 1;
    linesCleared = 0;
    dropInterval = 1000;
    lastDropTime = 0;
    gameOver = false;
    isPaused = false;
    currentPiece = randomPiece();
    nextPiece = randomPiece();
    drawNextPiece();
    updateScoreLevel();
    
    // Hide menu, show game elements
    menuScreen.classList.add('hidden');
    gameOverlay.classList.add('hidden');
    topUIDiv.classList.remove('hidden');
    gameContainer.classList.remove('hidden');
    controls.classList.remove('hidden');
    pauseBtn.classList.remove('hidden');
    resumeBtn.classList.add('hidden');

    preloadSounds();
    animationFrameId = requestAnimationFrame(gameLoop);
    playSound('start');
  }

  function showGameOver() {
    gameOverlay.classList.remove('hidden');
    finalScoreEl.textContent = score;
  }

  function pauseGame() {
    if(gameOver) return;
    isPaused = true;
    pauseBtn.classList.add('hidden');
    resumeBtn.classList.remove('hidden');
    playSound('pause');
  }

  function resumeGame() {
    if(gameOver) return;
    isPaused = false;
    lastDropTime = performance.now();
    pauseBtn.classList.remove('hidden');
    resumeBtn.classList.add('hidden');
    playSound('resume');
    requestAnimationFrame(gameLoop); // Restart animation frame
  }

  // Sound files (ensure these files exist in a 'sounds/' folder)
  const sounds = {
    move: new Audio('sounds/move.wav'),
    rotate: new Audio('sounds/rotate.wav'),
    down: new Audio('sounds/down.wav'),
    clear: new Audio('sounds/clear.wav'),
    fail: new Audio('sounds/fail.wav'),
    start: new Audio('sounds/start.wav'),
    pause: new Audio('sounds/pause.wav'),
    resume: new Audio('sounds/resume.wav'),
    gameover: new Audio('sounds/gameover.wav'),
    harddrop: new Audio('sounds/harddrop.wav'),
    lock: new Audio('sounds/lock.wav'),
  };

  function playSound(name) {
    const sound = sounds[name];
    if(sound) {
      // Clone node to allow overlapping playback for rapid actions (e.g., fast down moves)
      const clonedSound = sound.cloneNode();
      clonedSound.volume = 0.7; // Reduce volume slightly if sounds are too loud
      clonedSound.play().catch(e => console.log("Sound playback failed for", name, ":", e));
    }
  }

  // Event listeners for touch controls
  startBtn.addEventListener('click', startGame);
  restartBtn.addEventListener('click', () => {
    gameOverlay.classList.add('hidden');
    startGame();
  });

  pauseBtn.addEventListener('click', pauseGame);
  resumeBtn.addEventListener('click', resumeGame);

  document.getElementById('leftBtn').addEventListener('click', () => movePiece(-1,0));
  document.getElementById('rightBtn').addEventListener('click', () => movePiece(1,0));
  document.getElementById('rotateBtn').addEventListener('click', rotatePiece);
  document.getElementById('downBtn').addEventListener('click', () => movePiece(0,1));
  hardDropBtn.addEventListener('click', hardDrop);

  // Prevent scrolling on mobile when interacting with controls
  window.addEventListener('touchmove', function(e){
    // Only prevent default if the touch is within the game container or controls
    if(gameContainer.contains(e.target) || controls.contains(e.target) || topUIDiv.contains(e.target)) {
      e.preventDefault();
    }
  }, { passive:false });

  // Initial setup: Ensure menu screen is visible at start, others are hidden
  document.addEventListener('DOMContentLoaded', () => {
    menuScreen.classList.remove('hidden');
    gameOverlay.classList.add('hidden');
    topUIDiv.classList.add('hidden');
    gameContainer.classList.add('hidden');
    controls.classList.add('hidden');
    setCanvasDimensions(); // Set initial canvas size on load
  });

</script>
</body>
</html>