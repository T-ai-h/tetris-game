<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Tetris Mobile Game</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<style>
  body {
    margin: 0;
    font-family: 'Press Start 2P', cursive;
    background: linear-gradient(to bottom, #1a1a1a, #000); /* พื้นหลังไล่เฉด */
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    padding: 15px; /* เพิ่ม padding รอบด้าน */
    box-sizing: border-box;
    overflow: hidden; /* ป้องกันการ scroll โดยไม่ตั้งใจ */
  }

  h1 {
    text-shadow: 3px 3px 0px rgba(0,0,0,0.5); /* เงาชัดเจนขึ้น */
    color: #fff;
    letter-spacing: 2px;
  }

  /* --- Utility Class --- */
  .hidden {
    display: none !important;
  }

  /* --- Menu & Game Over Screens --- */
  #menuScreen, #gameOverlay {
    text-align: center;
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    background-color: rgba(0, 0, 0, 0.7); /* พื้นหลังโปร่งใสเล็กน้อย */
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); /* เงาสีฟ้าเรืองแสง */
  }

  #gameOverlay div {
    margin-bottom: 20px;
    font-size: 1.3em;
    color: #ff4d4d; /* สีแดงสด */
    text-shadow: 1px 1px 0px #800;
  }

  /* --- Top UI (Score, Level, Next Piece) --- */
  #topUI {
    display: flex; /* เปลี่ยนจาก none เป็น flex */
    flex-direction: row;
    align-items: flex-end; /* จัดให้ next piece ชิดด้านล่างของ flex item */
    justify-content: space-around; /* กระจายช่องไฟ */
    gap: 20px;
    margin: 15px 0;
    width: 100%;
    max-width: 380px; /* จำกัดความกว้างรวม */
    padding: 10px;
    box-sizing: border-box;
  }

  #scoreLevel {
    font-size: 14px;
    line-height: 1.6;
    text-align: left;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 10px 15px;
    border-radius: 8px;
    border: 2px solid #555;
    box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.2);
    min-width: 120px; /* ให้มีพื้นที่เพียงพอ */
  }

  #next {
    background-color: #222;
    border: 3px solid #777; /* ขอบหนาขึ้น */
    width: 90px; /* ขนาดใหญ่ขึ้นเล็กน้อย */
    height: 90px;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), inset 0 0 8px rgba(255, 255, 255, 0.1);
    border-radius: 5px;
  }

  /* --- Game Canvas --- */
  #gameContainer {
    display: block; /* เปลี่ยนจาก none เป็น block */
    border: 5px solid #fff; /* ขอบหนาและชัดเจน */
    box-shadow: 0 0 25px rgba(0, 255, 255, 0.6); /* เงาสีฟ้าเรืองแสงใหญ่ขึ้น */
    background-color: #0d0d0d; /* สีพื้นหลังเกม */
    border-radius: 8px;
    overflow: hidden; /* เพื่อให้บล็อกไม่ล้นขอบ */
  }

  #game {
    background-color: #1a1a1a;
  }

  /* --- Controls --- */
  #controls {
    display: grid; /* เปลี่ยนจาก none เป็น grid */
    grid-template-columns: repeat(3, 1fr); /* 3 คอลัมน์ */
    grid-template-rows: repeat(3, auto); /* 3 แถว, ขนาดตามเนื้อหา */
    gap: 12px; /* ลดระยะห่างเล็กน้อย */
    margin-top: 25px;
    padding: 15px;
    max-width: 380px; /* จำกัดความกว้างของ grid */
    box-sizing: border-box;
  }

  #controls button, #menuScreen button, #gameOverlay button {
    width: 100%; /* ปุ่มเต็มความกว้างใน grid cell */
    height: 60px; /* เพิ่มความสูง */
    font-family: 'Press Start 2P', cursive;
    font-size: 20px; /* ขนาดตัวอักษรใหญ่ขึ้น */
    background-color: #007bff; /* สีน้ำเงินสดใส */
    color: #fff;
    border: none;
    border-radius: 8px; /* มุมโค้งมนเล็กน้อย */
    box-shadow: 0 5px 0px #0056b3; /* เงาด้านล่างปุ่ม */
    cursor: pointer;
    transition: all 0.1s ease; /* เปลี่ยนแปลงนุ่มนวลขึ้น */
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    text-shadow: 1px 1px 0px rgba(0,0,0,0.3);
  }

  #controls button:active, #menuScreen button:active, #gameOverlay button:active {
    background-color: #0056b3; /* สีเข้มขึ้นเมื่อกด */
    transform: translateY(3px); /* เลื่อนลงเล็กน้อยเมื่อกด */
    box-shadow: 0 2px 0px #003f8e; /* เงาเล็กลงเมื่อกด */
  }

  /* Grid Area สำหรับปุ่มควบคุม */
  #pauseBtn, #resumeBtn {
    grid-column: 1;
    grid-row: 1;
  }
  #rotateBtn {
    grid-column: 2;
    grid-row: 1;
  }
  #hardDropBtn {
    grid-column: 3;
    grid-row: 1;
  }
  #leftBtn {
    grid-column: 1;
    grid-row: 2;
  }
  #downBtn {
    grid-column: 2;
    grid-row: 2;
  }
  #rightBtn {
    grid-column: 3;
    grid-row: 2;
  }

  /* ทำให้ปุ่ม Hard Drop หรือปุ่มอื่นๆ ที่คุณต้องการอยู่แถวเดียวกับ pause/resume */
  /* หรือถ้าต้องการปุ่ม Hard Drop แถวล่างสุดเต็มความกว้าง */
  #hardDropBtn.full-width { /* เพิ่ม class นี้ให้ปุ่ม Hard Drop ถ้าอยากให้เต็มความกว้าง */
    grid-column: 1 / span 3;
    grid-row: 3;
    max-width: none;
  }

  /* Responsive Adjustments */
  @media (max-width: 450px) {
    body {
      padding: 10px;
    }
    #topUI {
      gap: 15px;
      margin: 10px 0;
    }
    #scoreLevel {
      font-size: 12px;
      padding: 8px 12px;
    }
    #next {
      width: 80px;
      height: 80px;
    }
    #controls {
      gap: 10px;
      padding: 10px;
    }
    #controls button, #menuScreen button, #gameOverlay button {
      height: 55px;
      font-size: 18px;
    }
  }

  @media (max-width: 320px) {
    #topUI {
      flex-direction: column; /* บนจอเล็กมากให้ stack กัน */
      align-items: center;
    }
    #controls {
      max-width: 280px;
    }
  }

</style>
</head>
<body>

<div id="menuScreen">
  <h1>TETRIS MOBILE</h1>
  <button id="startBtn">เริ่มเล่น</button>
</div>

<div id="gameOverlay" class="hidden"> <div>เกมจบ!</div>
  <div>คะแนนสุดท้าย: <span id="finalScore">0</span></div>
  <button id="restartBtn">เล่นใหม่</button>
</div>

<div id="topUI" class="hidden"> <div id="scoreLevel">
    <div>คะแนน: <span id="score">0</span></div>
    <div>ระดับ: <span id="level">1</span></div>
  </div>
  <canvas id="next" width="90" height="90"></canvas>
</div>

<div id="gameContainer" class="hidden"> <canvas id="game" width="300" height="600"></canvas>
</div>

<div id="controls" class="hidden"> <button id="pauseBtn" title="Pause" aria-label="Pause">⏸️</button>
  <button id="rotateBtn">⟳</button>
  <button id="hardDropBtn">⚡</button>
  <button id="leftBtn">←</button>
  <button id="downBtn">↓</button>
  <button id="rightBtn">→</button>
  <button id="resumeBtn" title="Play" aria-label="Play" class="hidden">▶️</button> </div>

<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const finalScoreEl = document.getElementById('finalScore');
  const menuScreen = document.getElementById('menuScreen');
  const gameOverlay = document.getElementById('gameOverlay');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const topUIDiv = document.getElementById('topUI'); // เปลี่ยนชื่อตัวแปร
  const gameContainer = document.getElementById('gameContainer');
  const controls = document.getElementById('controls');
  const hardDropBtn = document.getElementById('hardDropBtn');

  const ROWS = 20;
  const COLS = 10;
  const BLOCK_SIZE = canvas.width / COLS;

  // ชนิดบล็อกและสี
  const SHAPES = [
    [],
    [[1,1,1,1]], // I
    [[1,1,0],[0,1,1]], // Z
    [[0,1,1],[1,1,0]], // S
    [[1,1,1],[0,1,0]], // T
    [[1,1],[1,1]], // O
    [[1,0,0],[1,1,1]], // L
    [[0,0,1],[1,1,1]], // J
  ];
  const COLORS = [
    null,
    '#00ffff', // I - Cyan
    '#ff0000', // Z - Red
    '#00ff00', // S - Green
    '#aa00ff', // T - Purple
    '#ffff00', // O - Yellow
    '#ff8800', // L - Orange
    '#0000ff', // J - Blue
  ];

  let board = [];
  let currentPiece = null;
  let nextPiece = null;
  let score = 0;
  let level = 1;
  let linesCleared = 0;
  let gameOver = false;
  let dropInterval = 1000;
  let lastDropTime = 0;
  let isPaused = false;
  let animationFrameId = null;

  function resetBoard() {
    board = [];
    for(let r=0; r<ROWS; r++) {
      board.push(new Array(COLS).fill(0));
    }
  }

  function randomPiece() {
    const id = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
    return {
      id: id,
      shape: SHAPES[id],
      color: COLORS[id],
      x: Math.floor(COLS/2) - Math.ceil(SHAPES[id][0].length/2),
      y: 0
    };
  }

  function drawBlock(x, y, color, context=ctx, alpha = 1) {
    context.fillStyle = color;
    context.globalAlpha = alpha;
    context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    context.strokeStyle = 'rgba(255,255,255,0.15)'; /* ขอบบล็อก */
    context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    context.globalAlpha = 1;
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        if(board[r][c]) {
          drawBlock(c, r, COLORS[board[r][c]]);
        }
      }
    }
  }

  function drawPiece(piece, context=ctx, alpha = 1) {
    piece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value) {
          drawBlock(piece.x + x, piece.y + y, piece.color, context, alpha);
        }
      });
    });
  }

  function drawNextPiece() {
    nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    if(!nextPiece) return;

    // คำนวณ offset เพื่อจัดตำแหน่งบล็อกให้อยู่ตรงกลาง nextCanvas
    const pieceWidth = nextPiece.shape[0].length;
    const pieceHeight = nextPiece.shape.length;
    const blockSizeNext = nextCanvas.width / 4; // ขนาดบล็อกใน nextCanvas (เพื่อให้พอดี 4x4)

    let startX = (nextCanvas.width - pieceWidth * blockSizeNext) / 2;
    let startY = (nextCanvas.height - pieceHeight * blockSizeNext) / 2;

    nextPiece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value) {
          nextCtx.fillStyle = nextPiece.color;
          nextCtx.fillRect(startX + x * blockSizeNext, startY + y * blockSizeNext, blockSizeNext - 2, blockSizeNext - 2);
          nextCtx.strokeStyle = 'rgba(255,255,255,0.2)';
          nextCtx.strokeRect(startX + x * blockSizeNext, startY + y * blockSizeNext, blockSizeNext - 2, blockSizeNext - 2);
        }
      });
    });
  }

  function collides(piece, board, offsetX, offsetY) {
    for(let y=0; y < piece.shape.length; y++) {
      for(let x=0; x < piece.shape[y].length; x++) {
        if(piece.shape[y][x]) {
          const newX = piece.x + x + offsetX;
          const newY = piece.y + y + offsetY;
          if(newX < 0 || newX >= COLS || newY >= ROWS) return true;
          if(newY >= 0 && board[newY][newX]) return true;
        }
      }
    }
    return false;
  }

  function mergePiece(piece, board) {
    piece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value && piece.y + y >= 0) {
          board[piece.y + y][piece.x + x] = piece.id;
        }
      });
    });
  }

  function rotate(piece) {
    const newShape = [];
    const rows = piece.shape.length;
    const cols = piece.shape[0].length;
    for(let x=0; x<cols; x++) {
      newShape[x] = [];
      for(let y=rows-1; y>=0; y--) {
        newShape[x][rows - 1 - y] = piece.shape[y][x];
      }
    }
    return newShape;
  }

  function rotatePiece() {
    if(isPaused || gameOver) return;
    const rotatedShape = rotate(currentPiece);
    const originalShape = currentPiece.shape;
    currentPiece.shape = rotatedShape;

    // Wall Kick - ตรวจสอบการชนและพยายามขยับเล็กน้อย
    const kicks = [
        [0, 0], // No kick
        [-1, 0], // Kick left
        [1, 0],  // Kick right
        [0, -1], // Kick up
        [-2, 0], // Double kick left
        [2, 0]   // Double kick right
    ];

    let rotatedSuccessfully = false;
    for (let i = 0; i < kicks.length; i++) {
        const [offsetX, offsetY] = kicks[i];
        if (!collides(currentPiece, board, offsetX, offsetY)) {
            currentPiece.x += offsetX;
            currentPiece.y += offsetY;
            rotatedSuccessfully = true;
            break;
        }
    }

    if (!rotatedSuccessfully) {
        currentPiece.shape = originalShape; // Revert if all kicks fail
        playSound('fail');
    } else {
        playSound('rotate');
    }
    draw();
  }

  function movePiece(offsetX, offsetY) {
    if(isPaused || gameOver) return;
    if(!collides(currentPiece, board, offsetX, offsetY)) {
      currentPiece.x += offsetX;
      currentPiece.y += offsetY;
      if (offsetY === 1) playSound('down');
      else if (offsetX !== 0) playSound('move');
      draw();
      return true;
    } else {
      if(offsetY === 1) { // If piece hits bottom or other blocks
        lockPiece();
      }
      return false;
    }
  }

  function hardDrop() {
    if(isPaused || gameOver) return;
    let linesDropped = 0;
    while (!collides(currentPiece, board, 0, 1)) {
      currentPiece.y++;
      linesDropped++;
    }
    score += linesDropped * 2; // Score for hard drop
    lockPiece();
    playSound('harddrop');
    draw();
  }

  function lockPiece() {
    mergePiece(currentPiece, board);
    clearLines();
    spawnNextPiece();
    if(collides(currentPiece, board, 0, 0)) {
      gameOver = true;
      showGameOver();
      playSound('gameover');
    } else {
      playSound('lock');
    }
  }

  function clearLines() {
    let lines = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (!board[y][x]) continue outer;
      }
      board.splice(y, 1);
      board.unshift(new Array(COLS).fill(0));
      lines++;
      y++;
    }

    if (lines > 0) {
      linesCleared += lines;
      // Score based on multiple lines cleared
      switch (lines) {
        case 1: score += 100 * level; break;
        case 2: score += 300 * level; break;
        case 3: score += 500 * level; break;
        case 4: score += 800 * level; break; // Tetris
      }

      const newLevel = Math.floor(linesCleared / 10) + 1;
      if (newLevel !== level) {
        level = newLevel;
        dropInterval = Math.max(50, 1000 - (level - 1) * 70); // Min drop interval 50ms
      }

      scoreEl.textContent = score;
      levelEl.textContent = level;
      playSound('clear');
    }
  }

  function getGhostPiece() {
    const ghost = { ...currentPiece };
    while (!collides(ghost, board, 0, 1)) {
      ghost.y++;
    }
    return ghost;
  }

  function spawnNextPiece() {
    currentPiece = nextPiece;
    currentPiece.x = Math.floor(COLS/2) - Math.ceil(currentPiece.shape[0].length/2);
    currentPiece.y = 0;
    nextPiece = randomPiece();
    drawNextPiece();
  }

  function updateScoreLevel() {
    scoreEl.textContent = score;
    levelEl.textContent = level;
  }

  function draw() {
    drawBoard();
    if (!gameOver && !isPaused) {
      const ghostPiece = getGhostPiece();
      drawPiece(ghostPiece, ctx, 0.2); // Draw ghost piece with transparency
      drawPiece(currentPiece);
    }
  }

  function gameLoop(timestamp) {
    if(gameOver || isPaused) {
      animationFrameId = requestAnimationFrame(gameLoop);
      return;
    }
    if(!lastDropTime) lastDropTime = timestamp;
    const delta = timestamp - lastDropTime;
    if(delta > dropInterval) {
      movePiece(0,1);
      lastDropTime = timestamp;
    }
    draw();
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  function preloadSounds() {
    for (const key in sounds) {
      if (sounds[key].src) {
        sounds[key].load();
      }
    }
  }

  function startGame() {
    resetBoard();
    score = 0;
    level = 1;
    linesCleared = 0;
    dropInterval = 1000;
    lastDropTime = 0;
    gameOver = false;
    isPaused = false;
    currentPiece = randomPiece();
    nextPiece = randomPiece();
    drawNextPiece();
    updateScoreLevel();
    
    // Hide menu, show game elements
    menuScreen.classList.add('hidden');
    gameOverlay.classList.add('hidden');
    topUIDiv.classList.remove('hidden');
    gameContainer.classList.remove('hidden');
    controls.classList.remove('hidden');
    pauseBtn.classList.remove('hidden');
    resumeBtn.classList.add('hidden');

    preloadSounds();
    animationFrameId = requestAnimationFrame(gameLoop);
    playSound('start');
  }

  function showGameOver() {
    gameOverlay.classList.remove('hidden');
    finalScoreEl.textContent = score;
  }

  function pauseGame() {
    if(gameOver) return;
    isPaused = true;
    pauseBtn.classList.add('hidden');
    resumeBtn.classList.remove('hidden');
    playSound('pause');
  }

  function resumeGame() {
    if(gameOver) return;
    isPaused = false;
    lastDropTime = performance.now();
    pauseBtn.classList.remove('hidden');
    resumeBtn.classList.add('hidden');
    playSound('resume');
    requestAnimationFrame(gameLoop); // Restart animation frame
  }

  // Sound files (ensure these files exist in a 'sounds/' folder)
  const sounds = {
    move: new Audio('sounds/move.wav'),
    rotate: new Audio('sounds/rotate.wav'),
    down: new Audio('sounds/down.wav'),
    clear: new Audio('sounds/clear.wav'),
    fail: new Audio('sounds/fail.wav'),
    start: new Audio('sounds/start.wav'),
    pause: new Audio('sounds/pause.wav'),
    resume: new Audio('sounds/resume.wav'),
    gameover: new Audio('sounds/gameover.wav'),
    harddrop: new Audio('sounds/harddrop.wav'),
    lock: new Audio('sounds/lock.wav'),
  };

  function playSound(name) {
    const sound = sounds[name];
    if(sound) {
      // Clone node to allow overlapping playback for rapid actions (e.g., fast down moves)
      const clonedSound = sound.cloneNode();
      clonedSound.volume = 0.7; // Reduce volume slightly if sounds are too loud
      clonedSound.play().catch(e => console.log("Sound playback failed for", name, ":", e));
    }
  }

  // Event listeners
  startBtn.addEventListener('click', startGame);
  restartBtn.addEventListener('click', () => {
    gameOverlay.classList.add('hidden');
    startGame();
  });

  pauseBtn.addEventListener('click', pauseGame);
  resumeBtn.addEventListener('click', resumeGame);

  document.getElementById('leftBtn').addEventListener('click', () => movePiece(-1,0));
  document.getElementById('rightBtn').addEventListener('click', () => movePiece(1,0));
  document.getElementById('rotateBtn').addEventListener('click', rotatePiece);
  document.getElementById('downBtn').addEventListener('click', () => movePiece(0,1));
  hardDropBtn.addEventListener('click', hardDrop);

  // Prevent scrolling on mobile when interacting with controls
  window.addEventListener('touchmove', function(e){
    // Only prevent default if the touch is within the game container or controls
    if(gameContainer.contains(e.target) || controls.contains(e.target)) {
      e.preventDefault();
    }
  }, { passive:false });

  // Keyboard controls (for desktop testing)
  document.addEventListener('keydown', e => {
    if (gameOver || isPaused) {
      // Allow 'r' to restart from game over screen
      if (e.key === 'r' && gameOver) {
        restartBtn.click();
      }
      // Allow 'p' to toggle pause/resume
      if (e.key === 'p' && !gameOver) {
        if (isPaused) resumeGame();
        else pauseGame();
      }
      return;
    }
    switch (e.key) {
      case 'ArrowLeft':
        movePiece(-1, 0);
        break;
      case 'ArrowRight':
        movePiece(1, 0);
        break;
      case 'ArrowUp': // Rotate
        rotatePiece();
        break;
      case 'ArrowDown': // Move down
        movePiece(0, 1);
        break;
      case ' ': // Space bar for Hard Drop
        hardDrop();
        break;
      case 'p': // P for pause
        pauseGame();
        break;
    }
  });

  // Initial setup: Ensure menu screen is visible at start, others are hidden
  document.addEventListener('DOMContentLoaded', () => {
    menuScreen.classList.remove('hidden');
    gameOverlay.classList.add('hidden');
    topUIDiv.classList.add('hidden');
    gameContainer.classList.add('hidden');
    controls.classList.add('hidden');
  });

</script>
</body>
</html>