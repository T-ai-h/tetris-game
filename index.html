<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris Mobile Full</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0; padding: 0;
      background: #000;
      color: #fff;
      font-family: monospace;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #menuScreen, #gameOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 999;
    }
    #startBtn, #restartBtn, #pauseBtn, #resumeBtn {
      margin-top: 20px;
      padding: 15px 30px;
      font-size: 1.4em;
      border: none;
      border-radius: 10px;
      background: #0f0;
      color: black;
      cursor: pointer;
      user-select: none;
    }
    #startBtn:hover, #restartBtn:hover, #pauseBtn:hover, #resumeBtn:hover {
      background: #3f3;
    }
    #scoreLevel {
      margin: 12px 0;
      font-size: 1.3em;
      text-align: center;
    }
    #gameContainer {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      width: 100%;
      max-width: 450px;
    }
    canvas {
      image-rendering: pixelated;
      background: #111;
      border: 2px solid #555;
    }
    #game {
      width: 300px;
      height: 600px;
    }
    #next {
      width: 120px;
      height: 120px;
    }
    #controls {
      display: flex;
      justify-content: center;
      gap: 12px;
      padding: 12px;
      flex-wrap: wrap;
      width: 100%;
      max-width: 450px;
    }
    #controls button {
      flex: 1;
      padding: 15px 0;
      font-size: 1.8em;
      border-radius: 8px;
      border: none;
      background: #333;
      color: white;
      max-width: 70px;
      user-select: none;
    }
    #controls button:active {
      background: #555;
    }
    @media (max-width: 400px) {
      #game { width: 240px; height: 480px; }
      #next { width: 90px; height: 90px; }
    }
  </style>
</head>
<body>

  <div id="menuScreen">
    <h1 style="font-size:2.5em; margin:0;">TETRIS</h1>
    <button id="startBtn">Start Game</button>
  </div>

  <div id="scoreLevel" style="display:none;">
    Score: <span id="score">0</span> | Level: <span id="level">1</span>
  </div>

  <div id="gameContainer" style="display:none;">
    <canvas id="game" width="300" height="600"></canvas>
    <canvas id="next" width="120" height="120"></canvas>
  </div>

  <div id="controls" style="display:none;">
    <button id="leftBtn">‚óÄÔ∏è</button>
    <button id="rightBtn">‚ñ∂Ô∏è</button>
    <button id="downBtn">‚¨áÔ∏è</button>
    <button id="rotateBtn">üîÑ</button>
    <button id="pauseBtn">‚è∏Ô∏è Pause</button>
    <button id="resumeBtn" style="display:none;">‚ñ∂Ô∏è Resume</button>
  </div>

  <div id="gameOverlay" style="display:none;">
    <div style="font-size:2em; margin-bottom:20px;">Game Over</div>
    <button id="restartBtn">Restart</button>
  </div>

<script>
(() => {
  // ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠
  const isMobile = /Mobi|Android/i.test(navigator.userAgent);
  if (!isMobile) {
    document.body.innerHTML = "<h2 style='color:white;text-align:center;margin-top:50px;'>Mobile Only</h2>";
    return;
  }

  // ‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡πÉ‡∏™‡πà‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå sounds/)
  const sound = {
    move: new Audio('sounds/move.wav'),
    rotate: new Audio('sounds/rotate.wav'),
    land: new Audio('sounds/land.wav'),
    clear: new Audio('sounds/clear.wav'),
    gameover: new Audio('sounds/gameover.wav'),
    levelup: new Audio('sounds/levelup.wav'),
  };
  function play(name) {
    if (sound[name]) {
      const s = sound[name].cloneNode();
      s.volume = 0.4;
      s.play();
    }
  }

  // ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÅ‡∏•‡∏∞ element
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const overlay = document.getElementById('gameOverlay');
  const restartBtn = document.getElementById('restartBtn');
  const startBtn = document.getElementById('startBtn');
  const menu = document.getElementById('menuScreen');
  const scoreLevel = document.getElementById('scoreLevel');
  const gameContainer = document.getElementById('gameContainer');
  const controls = document.getElementById('controls');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');

  const COLS = 10, ROWS = 20, BLOCK = 30;
  const COLORS = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];

  // ‡∏£‡∏π‡∏õ‡∏ó‡∏£‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å Tetris (4x4 matrix)
  const SHAPES = [
    [],
    [
      [0,0,0,0],
      [0,1,0,0],
      [1,1,1,0],
      [0,0,0,0]
    ], // T
    [
      [0,0,1,0],
      [0,0,1,0],
      [0,0,1,0],
      [0,0,1,0]
    ], // I
    [
      [0,0,0,0],
      [0,1,1,0],
      [1,1,0,0],
      [0,0,0,0]
    ], // S
    [
      [0,0,0,0],
      [1,1,0,0],
      [0,1,1,0],
      [0,0,0,0]
    ], // Z
    [
      [0,1,0,0],
      [0,1,0,0],
      [1,1,0,0],
      [0,0,0,0]
    ], // J
    [
      [0,0,0,0],
      [0,1,1,0],
      [0,1,1,0],
      [0,0,0,0]
    ], // O
    [
      [0,1,0,0],
      [0,1,0,0],
      [0,1,1,0],
      [0,0,0,0]
    ]  // L
  ];

  let board, current, next, dropCounter, dropInterval, lastTime, score, level, linesCleared, gameOver, paused;

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏°
  function randomPiece() {
    const type = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
    return { type, shape: SHAPES[type].map(row => row.slice()), x: 3, y: -2 };
  }

  // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà
  function reset() {
    board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    current = randomPiece();
    next = randomPiece();
    dropCounter = 0;
    dropInterval = 1000;
    lastTime = 0;
    score = 0;
    level = 1;
    linesCleared = 0;
    gameOver = false;
    paused = false;
    scoreEl.textContent = score;
    levelEl.textContent = level;
    overlay.style.display = 'none';
    scoreLevel.style.display = 'block';
    gameContainer.style.display = 'flex';
    controls.style.display = 'flex';
    menu.style.display = 'none';
    resumeBtn.style.display = 'none';
    pauseBtn.style.display = 'inline-block';
  }

  // ‡∏ß‡∏≤‡∏î‡∏ö‡∏•‡πá‡∏≠‡∏Å‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ä‡πà‡∏≠‡∏á‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
  function drawBlock(x, y, colorId) {
    if (colorId) {
      ctx.fillStyle = COLORS[colorId];
      ctx.fillRect(x * BLOCK, y * BLOCK, BLOCK - 1, BLOCK - 1);
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(x * BLOCK, y * BLOCK, BLOCK - 1, BLOCK - 1);
    } else {
      ctx.clearRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
    }
  }

  // ‡∏ß‡∏≤‡∏î‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
  function drawBoard() {
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        drawBlock(x, y, board[y][x]);
      }
    }
  }

  // ‡∏ß‡∏≤‡∏î‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏ï‡∏±‡∏ß‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
  function drawPiece(piece) {
    piece.shape.forEach((row, dy) => {
      row.forEach((val, dx) => {
        if (val) {
          drawBlock(piece.x + dx, piece.y + dy, piece.type);
        }
      });
    });
  }

  // ‡∏ß‡∏≤‡∏î‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏ï‡∏±‡∏ß‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
  function drawNext() {
    nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    next.shape.forEach((row, y) => {
      row.forEach((val, x) => {
        if (val) {
          nextCtx.fillStyle = COLORS[next.type];
          nextCtx.fillRect(x * 30, y * 30, 29, 29);
          nextCtx.strokeStyle = '#000';
          nextCtx.lineWidth = 2;
          nextCtx.strokeRect(x * 30, y * 30, 29, 29);
        }
      });
    });
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ä‡∏ô‡∏Å‡∏±‡∏ô
  function collide(board, piece) {
    for (let y = 0; y < piece.shape.length; y++) {
      for (let x = 0; x < piece.shape[y].length; x++) {
        if (piece.shape[y][x]) {
          let newX = piece.x + x;
          let newY = piece.y + y;
          if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
          if (newY >= 0 && board[newY][newX]) return true;
        }
      }
    }
    return false;
  }

  // ‡∏ú‡∏ô‡∏∂‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏Å‡∏±‡∏ö‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
  function merge(board, piece) {
    piece.shape.forEach((row, y) => {
      row.forEach((val, x) => {
        if (val && piece.y + y >= 0) {
          board[piece.y + y][piece.x + x] = piece.type;
        }
      });
    });
  }

  // ‡∏´‡∏°‡∏∏‡∏ô‡∏ö‡∏•‡πá‡∏≠‡∏Å 90 ‡∏≠‡∏á‡∏®‡∏≤ (‡∏ó‡∏ß‡∏ô‡πÄ‡∏Ç‡πá‡∏°‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤)
  function rotate(piece) {
    const N = piece.shape.length;
    let newShape = Array.from({ length: N }, () => Array(N).fill(0));
    for (let y = 0; y < N; y++) {
      for (let x = 0; x < N; x++) {
        newShape[y][x] = piece.shape[N - 1 - x][y];
      }
    }
    return newShape;
  }

  // ‡∏´‡∏°‡∏∏‡∏ô‡∏ö‡∏•‡πá‡∏≠‡∏Å‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ä‡∏ô
  function tryRotate() {
    const rotated = rotate(current);
    const oldShape = current.shape;
    current.shape = rotated;
    if (collide(board, current)) {
      current.shape = oldShape;
      return false;
    }
    play('rotate');
    return true;
  }

  // ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ö‡∏•‡πá‡∏≠‡∏Å
  function move(dir) {
    current.x += dir;
    if (collide(board, current)) {
      current.x -= dir;
      return false;
    }
    play('move');
    return true;
  }

  // ‡πÄ‡∏£‡πà‡∏á‡πÉ‡∏´‡πâ‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏•‡∏á‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô
  function drop() {
    current.y++;
    if (collide(board, current)) {
      current.y--;
      merge(board, current);
      play('land');
      clearLines();
      current = next;
      next = randomPiece();
      drawNext();
      if (collide(board, current)) {
        // game over
        gameOver = true;
        play('gameover');
        overlay.style.display = 'flex';
        controls.style.display = 'none';
        scoreLevel.style.display = 'none';
      }
      return false;
    }
    play('move');
    return true;
  }

  // ‡πÅ‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡∏ô‡∏Å‡∏£‡∏∞‡∏û‡∏£‡∏¥‡∏ö‡πÅ‡∏ñ‡∏ß‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏ö
  async function blinkAndClear(rows) {
    const blinkTimes = 5;
    for (let i = 0; i < blinkTimes; i++) {
      rows.forEach(row => {
        board[row].fill(i % 2 === 0 ? 0 : 8); // 8 = special color (white)
      });
      drawBoard();
      await new Promise(r => setTimeout(r, 100));
    }
    rows.forEach(row => board[row].fill(0));
  }

  // ‡∏•‡∏ö‡πÅ‡∏ñ‡∏ß‡πÄ‡∏ï‡πá‡∏° ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô
  async function clearLines() {
    let rowsToClear = [];
    for (let y = ROWS - 1; y >= 0; y--) {
      if (board[y].every(cell => cell !== 0)) {
        rowsToClear.push(y);
      }
    }
    if (rowsToClear.length > 0) {
      play('clear');
      await blinkAndClear(rowsToClear);
      rowsToClear.sort((a,b) => a - b);
      rowsToClear.forEach(row => board.splice(row, 1));
      rowsToClear.forEach(() => board.unshift(new Array(COLS).fill(0)));
      // ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô
      linesCleared += rowsToClear.length;
      score += 100 * rowsToClear.length * level;
      scoreEl.textContent = score;
      // ‡πÄ‡∏•‡πÄ‡∏ß‡∏•
      if (linesCleared >= level * 10) {
        level++;
        levelEl.textContent = level;
        dropInterval = Math.max(100, dropInterval - 100);
        play('levelup');
      }
    }
  }

  // ‡∏ß‡∏≤‡∏î‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBoard();
    drawPiece(current);
  }

  // ‡πÄ‡∏Å‡∏°‡∏•‡∏π‡∏õ
  function update(time = 0) {
    if (gameOver || paused) {
      lastTime = time;
      requestAnimationFrame(update);
      return;
    }
    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;
    if (dropCounter > dropInterval) {
      drop();
      dropCounter = 0;
    }
    draw();
    requestAnimationFrame(update);
  }

  // ‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° (‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠)
  document.getElementById('leftBtn').addEventListener('click', () => {
    if (!gameOver && !paused) move(-1);
  });
  document.getElementById('rightBtn').addEventListener('click', () => {
    if (!gameOver && !paused) move(1);
  });
  document.getElementById('downBtn').addEventListener('click', () => {
    if (!gameOver && !paused) drop();
  });
  document.getElementById('rotateBtn').addEventListener('click', () => {
    if (!gameOver && !paused) tryRotate();
  });

  // ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
  startBtn.onclick = () => {
    reset();
    drawNext();
    update();
  };

  // ‡∏õ‡∏∏‡πà‡∏°‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏Å‡∏°‡∏à‡∏ö
  restartBtn.onclick = () => {
    reset();
    drawNext();
    update();
  };

  // ‡∏õ‡∏∏‡πà‡∏° Pause/Resume
  pauseBtn.onclick = () => {
    paused = true;
    pauseBtn.style.display = 'none';
    resumeBtn.style.display = 'inline-block';
  };
  resumeBtn.onclick = () => {
    paused = false;
    pauseBtn.style.display = 'inline-block';
    resumeBtn.style.display = 'none';
  };

})();
</script>

</body>
</html>
