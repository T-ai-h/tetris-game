<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tetris Mobile</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #111;
      color: white;
      font-family: sans-serif;
    }

    #info {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      padding: 5px 15px;
      border-radius: 10px;
      z-index: 10;
      font-size: 16px;
    }

    #game {
      display: block;
      width: 100vw;
      aspect-ratio: 2/3; /* 10x15 */
      background: black;
      margin: auto;
    }

    #next {
      width: 80px;
      height: 80px;
      display: block;
      margin: 10px auto;
    }

    #controls {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 10px;
      z-index: 10;
    }

    button {
      width: 20vw;
      height: 20vw;
      max-width: 70px;
      max-height: 70px;
      font-size: 6vw;
      border-radius: 10px;
      border: none;
      background: #555;
      color: white;
      user-select: none;
      touch-action: manipulation;
    }

    button:active {
      background: #aaa;
    }

    #gameOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 20;
    }

    #gameOverlay button {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div id="info">Score: <span id="score">0</span> | Level: <span id="level">1</span></div>
  <canvas id="game"></canvas>
  <canvas id="next"></canvas>

  <div id="controls">
    <button id="leftBtn">◀️</button>
    <button id="downBtn">⬇️</button>
    <button id="rightBtn">▶️</button>
    <button id="rotateBtn">⟳</button>
  </div>

  <div id="gameOverlay">
    <div>Game Over</div>
    <button id="restartBtn">Restart</button>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const nextCanvas = document.getElementById("next");
    const nextCtx = nextCanvas.getContext("2d");
    const ROWS = 20, COLS = 10;

    let BLOCK_SIZE = 30;
    let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    let currentPiece, nextPiece, currentX, currentY;
    let dropSpeed = 700, gameInterval;
    let score = 0, level = 1;

    const scoreEl = document.getElementById("score");
    const levelEl = document.getElementById("level");
    const gameOverlay = document.getElementById("gameOverlay");
    const restartBtn = document.getElementById("restartBtn");

    const colors = [null, "#0ff", "#00f", "#fa0", "#ff0", "#0f0", "#a0f", "#f00"];
    const tetrominoes = [[],
      [[1,1,1,1]],
      [[2,0,0],[2,2,2]],
      [[0,0,3],[3,3,3]],
      [[4,4],[4,4]],
      [[0,5,5],[5,5,0]],
      [[0,6,0],[6,6,6]],
      [[7,7,0],[0,7,7]],
    ];

    function resizeCanvas() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      BLOCK_SIZE = canvas.width / COLS;
    }

    function drawBlock(x, y, colorId, context = ctx, size = BLOCK_SIZE) {
      context.fillStyle = colors[colorId];
      context.fillRect(x * size, y * size, size, size);
      context.strokeStyle = "#222";
      context.strokeRect(x * size, y * size, size, size);
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c]) drawBlock(c, r, grid[r][c]);
        }
      }
    }

    function drawPiece(piece, x, y, context = ctx, size = BLOCK_SIZE) {
      piece.shape.forEach((row, dy) => {
        row.forEach((val, dx) => {
          if (val) drawBlock(x + dx, y + dy, piece.id, context, size);
        });
      });
    }

    function drawNextPiece() {
      nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
      let offsetX = 1, offsetY = 1;
      drawPiece(nextPiece, offsetX, offsetY, nextCtx, 20);
    }

    function randomPiece() {
      const id = Math.floor(Math.random() * (tetrominoes.length - 1)) + 1;
      return { id: id, shape: tetrominoes[id] };
    }

    function resetPiece() {
      currentPiece = nextPiece || randomPiece();
      nextPiece = randomPiece();
      drawNextPiece();
      currentX = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
      currentY = -1;
      if (!validMove(currentPiece, currentX, currentY)) gameOver();
    }

    function validMove(piece, x, y) {
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (piece.shape[r][c]) {
            const newX = x + c;
            const newY = y + r;
            if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && grid[newY][newX])) {
              return false;
            }
          }
        }
      }
      return true;
    }

    function lockPiece(piece, x, y) {
      piece.shape.forEach((row, r) => {
        row.forEach((val, c) => {
          if (val && y + r >= 0) grid[y + r][x + c] = piece.id;
        });
      });
    }

    function clearLines() {
      let lines = 0;
      outer: for (let r = ROWS - 1; r >= 0; r--) {
        for (let c = 0; c < COLS; c++) {
          if (!grid[r][c]) continue outer;
        }
        grid.splice(r, 1);
        grid.unshift(Array(COLS).fill(0));
        lines++;
      }
      if (lines) {
        score += lines * 10;
        scoreEl.textContent = score;
        updateSpeed();
      }
    }

    function updateSpeed() {
      level = Math.floor(score / 50) + 1;
      levelEl.textContent = level;
      dropSpeed = Math.max(100, 700 - (level - 1) * 50);
      clearInterval(gameInterval);
      gameInterval = setInterval(update, dropSpeed);
    }

    function rotate(piece) {
      const newShape = piece.shape[0].map((_, c) => piece.shape.map(row => row[c]).reverse());
      return { ...piece, shape: newShape };
    }

    function update() {
      if (validMove(currentPiece, currentX, currentY + 1)) {
        currentY++;
      } else {
        lockPiece(currentPiece, currentX, currentY);
        clearLines();
        resetPiece();
      }
      draw();
    }

    function draw() {
      drawGrid();
      drawPiece(currentPiece, currentX, currentY);
    }

    function gameOver() {
      clearInterval(gameInterval);
      gameOverlay.style.display = "flex";
    }

    restartBtn.onclick = () => {
      grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      score = 0;
      level = 1;
      scoreEl.textContent = score;
      levelEl.textContent = level;
      gameOverlay.style.display = "none";
      nextPiece = randomPiece();
      resetPiece();
      updateSpeed();
      draw();
    }

    // Controls
    const leftBtn = document.getElementById("leftBtn");
    const rightBtn = document.getElementById("rightBtn");
    const downBtn = document.getElementById("downBtn");
    const rotateBtn = document.getElementById("rotateBtn");

    leftBtn.onclick = () => handleMove("left");
    rightBtn.onclick = () => handleMove("right");
    downBtn.onclick = () => handleMove("down");
    rotateBtn.onclick = () => handleMove("rotate");

    function handleMove(dir) {
      if (gameOverlay.style.display === "flex") return;
      if (dir === "left" && validMove(currentPiece, currentX - 1, currentY)) currentX--;
      if (dir === "right" && validMove(currentPiece, currentX + 1, currentY)) currentX++;
      if (dir === "down") update();
      if (dir === "rotate") {
        const rotated = rotate(currentPiece);
        if (validMove(rotated, currentX, currentY)) currentPiece.shape = rotated.shape;
      }
      draw();
    }

    window.addEventListener("resize", () => {
      resizeCanvas();
      draw();
    });

    // Init
    resizeCanvas();
    nextPiece = randomPiece();
    resetPiece();
    updateSpeed();
    draw();
  </script>
</body>
</html>

<body>
<div id="info">Score: <span id="score">0</span> | Level: <span id="level">1</span></div>
<canvas id="game"></canvas>
<canvas id="next" width="120" height="120"></canvas>

<div id="controls">
  <button id="leftBtn">◀️</button>
  <button id="downBtn">⬇️</button>
  <button id="rightBtn">▶️</button>
  <button id="rotateBtn">⟳</button>
</div>

<div id="gameOverlay">
  <div>Game Over</div>
  <button id="restartBtn">Restart</button>
</div>

<div id="info">Score: <span id="score">0</span> | Level: <span id="level">1</span></div>

<script>
  const controls = document.getElementById("controls");
controls.addEventListener("touchmove", function(e) {
  e.preventDefault();  // ป้องกันเลื่อนหน้าเมื่อสัมผัสในโซนปุ่ม
}, { passive: false });

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const nextCanvas = document.getElementById("next");
const nextCtx = nextCanvas.getContext("2d");

const ROWS = 20;
const COLS = 10;
let BLOCK_SIZE = 30;
const NEXT_BLOCK_SIZE = 30;

let score = 0;
let level = 1;
const scoreEl = document.getElementById("score");
const levelEl = document.getElementById("level");

const gameOverlay = document.getElementById("gameOverlay");
const restartBtn = document.getElementById("restartBtn");

const colors = [
  null,
  "#00f0f0", "#0000f0", "#f0a000", "#f0f000",
  "#00f000", "#a000f0", "#f00000",
];

const tetrominoes = [
  [],
  [[1, 1, 1, 1]],
  [[2, 0, 0], [2, 2, 2]],
  [[0, 0, 3], [3, 3, 3]],
  [[4, 4], [4, 4]],
  [[0, 5, 5], [5, 5, 0]],
  [[0, 6, 0], [6, 6, 6]],
  [[7, 7, 0], [0, 7, 7]],
];

let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));

let currentPiece = null;
let currentX = 0;
let currentY = 0;
let nextPiece = null;

let dropSpeed = 700;
let gameInterval;

const leftBtn = document.getElementById("leftBtn");
const rightBtn = document.getElementById("rightBtn");
const downBtn = document.getElementById("downBtn");
const rotateBtn = document.getElementById("rotateBtn");

function randomPiece() {
  const id = Math.floor(Math.random() * (tetrominoes.length - 1)) + 1;
  return { id: id, shape: tetrominoes[id] };
}
function resizeCanvas() {
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  canvas.width = width;
  canvas.height = height;
  BLOCK_SIZE = width / COLS * 0.75;  // ลด block size ลง 75% ตัวอย่าง
}


function drawBlock(x, y, colorId, size = BLOCK_SIZE, context = ctx) {
  context.fillStyle = colors[colorId];
  context.fillRect(x * size, y * size, size, size);
  context.strokeStyle = "#222";
  context.lineWidth = 2;
  context.strokeRect(x * size, y * size, size, size);
}

function drawGrid() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (grid[r][c]) drawBlock(c, r, grid[r][c]);
    }
  }
}

function drawPiece(piece, x, y, context = ctx, size = BLOCK_SIZE) {
  piece.shape.forEach((row, dy) => {
    row.forEach((val, dx) => {
      if (val) drawBlock(x + dx, y + dy, piece.id, size, context);
    });
  });
}

function drawNextPiece() {
  nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
  const shape = nextPiece.shape;
  const offsetX = Math.floor((nextCanvas.width / NEXT_BLOCK_SIZE - shape[0].length) / 2);
  const offsetY = Math.floor((nextCanvas.height / NEXT_BLOCK_SIZE - shape.length) / 2);
  drawPiece(nextPiece, offsetX, offsetY, nextCtx, NEXT_BLOCK_SIZE);
}

function validMove(piece, x, y) {
  for (let r = 0; r < piece.shape.length; r++) {
    for (let c = 0; c < piece.shape[r].length; c++) {
      if (piece.shape[r][c]) {
        let newX = x + c;
        let newY = y + r;
        if (newX < 0 || newX >= COLS || newY >= ROWS) return false;
        if (newY >= 0 && grid[newY][newX]) return false;
      }
    }
  }
  return true;
}

function lockPiece(piece, x, y) {
  piece.shape.forEach((row, r) => {
    row.forEach((val, c) => {
      if (val && y + r >= 0) grid[y + r][x + c] = piece.id;
    });
  });
}

function clearLines() {
  let lines = 0;
  outer: for (let r = ROWS - 1; r >= 0; r--) {
    for (let c = 0; c < COLS; c++) {
      if (!grid[r][c]) continue outer;
    }
    grid.splice(r, 1);
    grid.unshift(Array(COLS).fill(0));
    lines++;
    r++;
  }
  if (lines > 0) {
    score += lines * 10;
    scoreEl.textContent = score;
    updateSpeed();
  }
}

function rotate(piece) {
  const oldShape = piece.shape;
  const rows = oldShape.length;
  const cols = oldShape[0].length;
  let newShape = [];
  for (let x = 0; x < cols; x++) {
    newShape[x] = [];
    for (let y = rows - 1; y >= 0; y--) {
      newShape[x][rows - 1 - y] = oldShape[y][x];
    }
  }
  return newShape;
}

function resetPiece() {
  currentPiece = nextPiece || randomPiece();
  nextPiece = randomPiece();
  drawNextPiece();
  currentX = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
  currentY = -1;
  if (!validMove(currentPiece, currentX, currentY)) gameOver();
}

function gameOver() {
  gameOverlay.style.display = "flex";
  clearInterval(gameInterval);
}

restartBtn.addEventListener("click", () => {
  gameOverlay.style.display = "none";
  grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
  score = 0; level = 1;
  scoreEl.textContent = score;
  levelEl.textContent = level;
  nextPiece = randomPiece();
  resetPiece();
  updateSpeed();
  draw();
});

let uiMoveInterval = null;

function startContinuousMove(direction) {
  if (gameOverlay.style.display === "flex") return;
  if (uiMoveInterval) return;
  handleMove(direction);
  uiMoveInterval = setInterval(() => handleMove(direction), 150);
}

function stopContinuousMove() {
  if (uiMoveInterval) {
    clearInterval(uiMoveInterval);
    uiMoveInterval = null;
  }
}

leftBtn.addEventListener("mousedown", () => startContinuousMove("left"));
leftBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startContinuousMove("left"); });
leftBtn.addEventListener("mouseup", stopContinuousMove);
leftBtn.addEventListener("mouseleave", stopContinuousMove);
leftBtn.addEventListener("touchend", stopContinuousMove);
leftBtn.addEventListener("touchcancel", stopContinuousMove);

rightBtn.addEventListener("mousedown", () => startContinuousMove("right"));
rightBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startContinuousMove("right"); });
rightBtn.addEventListener("mouseup", stopContinuousMove);
rightBtn.addEventListener("mouseleave", stopContinuousMove);
rightBtn.addEventListener("touchend", stopContinuousMove);
rightBtn.addEventListener("touchcancel", stopContinuousMove);

downBtn.addEventListener("mousedown", () => startContinuousMove("down"));
downBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startContinuousMove("down"); });
downBtn.addEventListener("mouseup", stopContinuousMove);
downBtn.addEventListener("mouseleave", stopContinuousMove);
downBtn.addEventListener("touchend", stopContinuousMove);
downBtn.addEventListener("touchcancel", stopContinuousMove);

rotateBtn.addEventListener("click", () => handleMove("rotate"));
rotateBtn.addEventListener("touchstart", (e) => { e.preventDefault(); handleMove("rotate"); });

function handleMove(direction) {
  if (gameOverlay.style.display === "flex") return;
  if (direction === "left" && validMove(currentPiece, currentX - 1, currentY)) currentX--;
  else if (direction === "right" && validMove(currentPiece, currentX + 1, currentY)) currentX++;
  else if (direction === "down") { update(); return; }
  else if (direction === "rotate") {
    const rotated = rotate(currentPiece);
    const test = { ...currentPiece, shape: rotated };
    if (validMove(test, currentX, currentY)) currentPiece.shape = rotated;
    else if (validMove(test, currentX - 1, currentY)) { currentX--; currentPiece.shape = rotated; }
    else if (validMove(test, currentX + 1, currentY)) { currentX++; currentPiece.shape = rotated; }
  }
  draw();
}

function update() {
  if (validMove(currentPiece, currentX, currentY + 1)) currentY++;
  else {
    lockPiece(currentPiece, currentX, currentY);
    clearLines();
    resetPiece();
  }
  draw();
}

function draw() {
  drawGrid();
  drawPiece(currentPiece, currentX, currentY);
}

function updateSpeed() {
  level = Math.floor(score / 50) + 1;
  levelEl.textContent = level;
  dropSpeed = Math.max(100, 700 - (level - 1) * 50);
  clearInterval(gameInterval);
  gameInterval = setInterval(update, dropSpeed);
  updateBackground();
}

function updateBackground() {
  const backgrounds = [
    "linear-gradient(135deg, #000000, #1a1a1a)",   // level 1: ดำเรียบ
    "linear-gradient(135deg, #004d4d, #009999)",   // level 2: เขียวฟ้า
    "linear-gradient(135deg, #00264d, #0059b3)",   // level 3: น้ำเงินเข้ม
    "linear-gradient(135deg, #33001a, #660033)",   // level 4: ม่วงแดง
    "linear-gradient(135deg, #331a00, #cc6600)",   // level 5: น้ำตาลส้ม
    "linear-gradient(135deg, #1a3300, #66cc00)",   // level 6: เขียวสด
    "linear-gradient(135deg, #4d004d, #990099)",   // level 7: ม่วงเจิดจ้า
    "linear-gradient(135deg, #003333, #00cccc)",   // level 8: ฟ้าน้ำทะเล
    "linear-gradient(135deg, #26004d, #9933ff)",   // level 9: ม่วงนีออน
    "linear-gradient(135deg, #0d0d0d, #333333)"    // level 10+: เทาเข้มคลาสสิก
  ];
  
  const bg = backgrounds[Math.min(level - 1, backgrounds.length - 1)];
  canvas.style.background = bg;
}


window.addEventListener('resize', () => {
  resizeCanvas();
  draw();
});

// ปิด scroll gesture (touchmove)
document.addEventListener('touchmove', function(e) {
  e.preventDefault();
}, { passive: false });

nextPiece = randomPiece();
resizeCanvas();
resetPiece();
updateSpeed();
draw();
</script>
</body>
</html>
