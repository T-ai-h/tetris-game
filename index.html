<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Tetris Mobile Game</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<style>
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 0;
    background: linear-gradient(135deg, #3f51b5, #9c27b0);
    color: #eee;
    font-family: 'Press Start 2P', cursive, monospace;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    user-select: none;
  }
  #menuScreen, #gameOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 999;
    text-shadow: 0 0 10px #fff;
  }
  #menuScreen h1 {
    font-size: 2.8em;
    color: #ff4081;
    margin-bottom: 40px;
    text-shadow:
      0 0 10px #ff4081,
      0 0 20px #e040fb,
      0 0 30px #7c4dff;
  }
  button {
    font-family: 'Press Start 2P', cursive, monospace;
    cursor: pointer;
    border: none;
    border-radius: 15px;
    padding: 20px 40px;
    font-size: 1em;
    color: #fff;
    background: linear-gradient(45deg, #ff4081, #7c4dff);
    box-shadow:
      0 0 15px #ff4081,
      0 0 30px #7c4dff;
    transition: all 0.3s ease;
    user-select: none;
  }
  button:hover {
    background: linear-gradient(45deg, #e040fb, #651fff);
    box-shadow:
      0 0 20px #e040fb,
      0 0 40px #651fff;
    transform: scale(1.05);
  }
  button:active {
    transform: scale(0.95);
    box-shadow: none;
  }
  #scoreLevel {
    margin: 12px 0;
    font-size: 1.2em;
    text-align: center;
    text-shadow: 0 0 8px #fff;
  }
  #gameContainer {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: 12px;
    width: 100%;
    max-width: 460px;
    padding: 10px;
    background: rgba(0,0,0,0.3);
    border-radius: 15px;
    box-shadow:
      0 0 15px #7c4dff,
      inset 0 0 20px #e040fb;
  }
  canvas {
    image-rendering: pixelated;
    background: #111;
    border-radius: 12px;
    border: 4px solid transparent;
    box-shadow:
      0 0 15px #7c4dff,
      inset 0 0 40px #e040fb;
  }
  #game {
    width: 300px;
    height: 600px;
  }
  #next {
    width: 140px;
    height: 140px;
    margin-top: 40px;
  }
  #controls {
    display: flex;
    justify-content: center;
    gap: 15px;
    padding: 12px 10px;
    flex-wrap: wrap;
    width: 100%;
    max-width: 460px;
    margin-top: 15px;
  }
  #controls button {
    flex: 1 1 60px;
    padding: 18px 0;
    font-size: 1.4em;
    border-radius: 12px;
    background: linear-gradient(135deg, #651fff, #d500f9);
    box-shadow:
      0 0 15px #d500f9,
      inset 0 0 10px #651fff;
    transition: all 0.3s ease;
    max-width: 80px;
    color: #fff;
    user-select: none;
  }
  #controls button:active {
    background: linear-gradient(135deg, #d500f9, #651fff);
    box-shadow: none;
    transform: scale(0.9);
  }
  #pauseBtn, #resumeBtn {
    width: 40px;
    height: 40px;
    border: none;
    background: transparent;
    cursor: pointer;
    position: relative;
    margin: 0 5px;
  }

  /* ปุ่มหยุด: สองขีดแนวตั้ง */
  #pauseBtn::before, #pauseBtn::after {
    content: '';
    position: absolute;
    top: 8px;
    width: 8px;
    height: 24px;
    background-color: #ddd;
    border-radius: 2px;
  }
  #pauseBtn::before {
    left: 10px;
  }
  #pauseBtn::after {
    right: 10px;
  }

  /* ปุ่มเล่น: รูปสามเหลี่ยมแนวขวา */
  #resumeBtn::before {
    content: '';
    position: absolute;
    top: 6px;
    left: 12px;
    width: 0;
    height: 0;
    border-top: 14px solid transparent;
    border-bottom: 14px solid transparent;
    border-left: 20px solid #ddd;
  }

  #pauseBtn:hover, #resumeBtn:hover {
    background: linear-gradient(135deg, #f50057, #c51162);
    box-shadow:
      0 0 25px #c51162,
      inset 0 0 20px #f50057;
  }
  #gameOverlay div {
    color: #ff1744;
    font-size: 3em;
    text-shadow:
      0 0 10px #ff1744,
      0 0 20px #f50057;
    margin-bottom: 30px;
  }
  @media (max-width: 400px) {
    #game { width: 240px; height: 480px; }
    #next { width: 110px; height: 110px; margin-top: 30px; }
    #controls button { font-size: 1.2em; max-width: 65px; padding: 15px 0; }
    #pauseBtn, #resumeBtn { max-width: 100px; font-size: 1em; margin-left: 5px;}
  }
</style>
</head>
<body>

<div id="menuScreen">
  <h1>TETRIS MOBILE</h1>
  <button id="startBtn">เริ่มเล่น</button>
</div>

<div id="gameOverlay" style="display:none;">
  <div>เกมจบ!</div>
  <button id="restartBtn">เล่นใหม่</button>
</div>

<div id="scoreLevel" style="display:none;">
  คะแนน: <span id="score">0</span> | ระดับ: <span id="level">1</span>
</div>

<div id="gameContainer" style="display:none;">
  <canvas id="game" width="300" height="600"></canvas>
  <canvas id="next" width="140" height="140"></canvas>
</div>

<div id="controls" style="display:none;">
  <button id="leftBtn">←</button>
  <button id="rightBtn">→</button>
  <button id="rotateBtn">⟳</button>
  <button id="downBtn">↓</button>
  <button id="pauseBtn" title="Pause" aria-label="Pause"></button>
  <button id="resumeBtn" title="Play" aria-label="Play" style="display:none;"></button>
</div>

<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const menuScreen = document.getElementById('menuScreen');
  const gameOverlay = document.getElementById('gameOverlay');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const rotateBtn = document.getElementById('rotateBtn');
  const downBtn = document.getElementById('downBtn');
  const scoreLevel = document.getElementById('scoreLevel');
  const gameContainer = document.getElementById('gameContainer');
  const controls = document.getElementById('controls');

  // เกมตั้งค่าเบื้องต้น
  const ROWS = 20;
  const COLS = 10;
  const BLOCK_SIZE = 30;
  const COLORS = [
    null,
    '#ff1744', // red
    '#ff9100', // orange
    '#ffea00', // yellow
    '#00e676', // green
    '#2979ff', // blue
    '#d500f9', // purple
    '#00bfa5'  // cyan
  ];

  // ชิ้นบล็อก Tetris
  const SHAPES = [
    [],
    [[1,1,1,1]],              // I
    [[2,2,0],[0,2,2]],       // Z
    [[0,3,3],[3,3,0]],       // S
    [[4,0,0],[4,4,4]],       // J
    [[0,0,5],[5,5,5]],       // L
    [[6,6,6],[0,6,0]],       // T
    [[7,7],[7,7]]            // O
  ];

  let board, current, next, pos, score, level, linesCleared, dropInterval, dropCounter, lastTime;
  let isPaused = false;

  function createMatrix(w, h) {
    const matrix = [];
    for(let i = 0; i < h; i++) {
      matrix.push(new Array(w).fill(0));
    }
    return matrix;
  }

  function collide(board, piece, pos) {
    for(let y=0; y < piece.length; y++) {
      for(let x=0; x < piece[y].length; x++) {
        if(piece[y][x] !== 0 && (board[y+pos.y] && board[y+pos.y][x+pos.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  function merge(board, piece, pos) {
    for(let y=0; y < piece.length; y++) {
      for(let x=0; x < piece[y].length; x++) {
        if(piece[y][x] !== 0) {
          board[y+pos.y][x+pos.x] = piece[y][x];
        }
      }
    }
  }

  function rotate(matrix, dir) {
    for(let y=0; y < matrix.length; y++) {
      for(let x=0; x < y; x++) {
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if(dir > 0) {
      matrix.forEach(row => row.reverse());
    } else {
      matrix.reverse();
    }
  }

  function drawMatrix(ctx, matrix, offset) {
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value !== 0) {
          ctx.fillStyle = COLORS[value];
          ctx.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          ctx.strokeStyle = '#222';
          ctx.lineWidth = 2;
          ctx.strokeRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      });
    });
  }

  function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawMatrix(ctx, board, {x:0, y:0});
    drawMatrix(ctx, current, pos);

    // next block
    nextCtx.fillStyle = '#111';
    nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
    const nx = Math.floor((nextCanvas.width / BLOCK_SIZE - next[0].length) / 2);
    const ny = Math.floor((nextCanvas.height / BLOCK_SIZE - next.length) / 2);
    drawMatrix(nextCtx, next, {x: nx, y: ny});
  }

  function clearLines() {
    let rowCount = 0;
    outer: for(let y=board.length-1; y>=0; y--) {
      for(let x=0; x<board[y].length; x++) {
        if(board[y][x] === 0) {
          continue outer;
        }
      }
      // ลบแถว
      const row = board.splice(y, 1)[0].fill(0);
      board.unshift(row);
      y++;
      rowCount++;
    }
    if(rowCount > 0) {
      linesCleared += rowCount;
      score += rowCount * 100 * level;
      // ปรับระดับทุก 10 แถว
      if(linesCleared >= level * 10) {
        level++;
        dropInterval = Math.max(100, 1000 - (level-1)*100);
      }
      scoreEl.textContent = score;
      levelEl.textContent = level;
      animateClear(rowCount);
    }
  }

  // แอนิเมชันกระพริบตอนลบแถว
  function animateClear(rows) {
    // กระพริบ 3 รอบ
    let blinkCount = 0;
    const blinkMax = 6;
    let visible = true;

    const interval = setInterval(() => {
      visible = !visible;
      ctx.fillStyle = visible ? '#fff' : '#111';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      if(visible) {
        drawMatrix(ctx, board, {x:0, y:0});
        drawMatrix(ctx, current, pos);
      }
      blinkCount++;
      if(blinkCount >= blinkMax) {
        clearInterval(interval);
      }
    }, 80);
  }

  function resetGame() {
    board = createMatrix(COLS, ROWS);
    current = createPiece();
    next = createPiece();
    pos = {x: Math.floor(COLS/2) - 1, y: 0};
    score = 0;
    level = 1;
    linesCleared = 0;
    dropInterval = 1000;
    dropCounter = 0;
    scoreEl.textContent = score;
    levelEl.textContent = level;
  }

  function createPiece() {
    const typeId = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
    // deep clone
    return SHAPES[typeId].map(row => row.slice());
  }

  function playerDrop() {
    if(isPaused) return;
    pos.y++;
    if(collide(board, current, pos)) {
      pos.y--;
      merge(board, current, pos);
      clearLines();
      current = next;
      next = createPiece();
      pos = {x: Math.floor(COLS/2) - 1, y: 0};
      if(collide(board, current, pos)) {
        // Game over
        endGame();
      }
    }
    dropCounter = 0;
    draw();
  }

  function playerMove(dir) {
    if(isPaused) return;
    pos.x += dir;
    if(collide(board, current, pos)) {
      pos.x -= dir;
    } else {
      draw();
    }
  }

  function playerRotate() {
    if(isPaused) return;
    const original = current.map(row => row.slice());
    rotate(current, 1);
    if(collide(board, current, pos)) {
      // ลองเลื่อนซ้ายขวาดู
      if(!tryWallKick()) {
        current = original;
      }
    }
    draw();
  }

  function tryWallKick() {
    const posX = pos.x;
    for(let offset of [1, -1, 2, -2]) {
      pos.x = posX + offset;
      if(!collide(board, current, pos)) {
        return true;
      }
    }
    pos.x = posX;
    return false;
  }

  function update(time = 0) {
    if(isPaused) {
      lastTime = time;
      requestAnimationFrame(update);
      return;
    }
    if(!lastTime) lastTime = time;
    const deltaTime = time - lastTime;
    lastTime = time;

    dropCounter += deltaTime;
    if(dropCounter > dropInterval) {
      playerDrop();
    }
    draw();
    requestAnimationFrame(update);
  }

  function startGame() {
    resetGame();
    menuScreen.style.display = 'none';
    gameOverlay.style.display = 'none';
    scoreLevel.style.display = 'block';
    gameContainer.style.display = 'flex';
    controls.style.display = 'flex';
    isPaused = false;
    pauseBtn.style.display = 'inline-block';
    resumeBtn.style.display = 'none';
    lastTime = 0;
    requestAnimationFrame(update);
  }

  function endGame() {
    isPaused = true;
    gameOverlay.style.display = 'flex';
  }

  // ควบคุมเสียงพื้นฐาน
  function playSound(id) {
    // ใส่โค้ดเล่นเสียงที่นี่ (ถ้ามี)
  }

  // ปุ่มควบคุม
  startBtn.addEventListener('click', () => {
    startGame();
  });

  restartBtn.addEventListener('click', () => {
    startGame();
  });

  pauseBtn.addEventListener('click', () => {
    isPaused = true;
    pauseBtn.style.display = 'none';
    resumeBtn.style.display = 'inline-block';
  });

  resumeBtn.addEventListener('click', () => {
    isPaused = false;
    lastTime = 0;
    pauseBtn.style.display = 'inline-block';
    resumeBtn.style.display = 'none';
    requestAnimationFrame(update);
  });

  leftBtn.addEventListener('click', () => playerMove(-1));
  rightBtn.addEventListener('click', () => playerMove(1));
  rotateBtn.addEventListener('click', () => playerRotate());
  downBtn.addEventListener('click', () => playerDrop());

  // รองรับการกดแป้นพิมพ์ (ถ้าเล่นบน PC)
  document.addEventListener('keydown', e => {
    if(isPaused) return;
    if(e.key === 'ArrowLeft') playerMove(-1);
    else if(e.key === 'ArrowRight') playerMove(1);
    else if(e.key === 'ArrowDown') playerDrop();
    else if(e.key === 'ArrowUp' || e.key === 'x') playerRotate();
  });

  // ป้องกัน zoom บนมือถือ (ถ้ามี)
  window.addEventListener('touchmove', e => {
    if(e.scale !== 1) e.preventDefault();
  }, {passive: false});
</script>

</body>
</html>
