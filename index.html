<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Tetris Mobile Game</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<style>
  body {
    margin: 0;
    font-family: 'Press Start 2P', cursive;
    background: linear-gradient(to bottom, #1a1a1a, #000);
    color: #fff;
    display: flex;
    flex-direction: column; /* body เป็น flex column หลัก */
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh; /* ใช้เต็มความสูงจอ */
    padding: 1vh 2vw; /* ใช้ vh และ vw สำหรับ padding เพื่อประหยัดพื้นที่ */
    box-sizing: border-box;
    overflow: hidden; /* ป้องกันการ scroll */
  }

  h1 {
    text-shadow: 3px 3px 0px rgba(0,0,0,0.5);
    color: #fff;
    letter-spacing: 2px;
    margin-top: 0.5vh;
    margin-bottom: 0.5vh;
    font-size: min(8vw, 5vh); /* ปรับขนาดให้เล็กลงนิดหน่อย */
    flex-shrink: 0; /* ไม่ให้ h1 หดตัว */
  }

  /* --- Utility Class --- */
  .hidden {
    display: none !important;
  }

  /* --- Main Game Wrapper --- */
  #mainGameWrapper {
    display: flex;
    flex-direction: column; /* จัดส่วนเกมหลักในแนวตั้ง */
    flex-grow: 1; /* ให้ขยายเต็มพื้นที่ที่เหลือใน body */
    width: 100%;
    max-width: min(95vw, 450px); /* จำกัดความกว้างรวม */
    box-sizing: border-box;
    justify-content: space-between; /* กระจายพื้นที่แนวตั้งระหว่างองค์ประกอบ */
    min-height: 0; /* จำเป็นสำหรับ flex item ที่มี flex-grow */
  }

  /* --- Menu & Game Over Screens --- */
  #menuScreen, #gameOverlay {
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2vh 5vw;
    background-color: rgba(0, 0, 0, 0.7);
    border-radius: 8px;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
    max-width: 90vw;
    box-sizing: border-box;
    position: absolute; /* ให้ลอยอยู่บนสุด */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 10; /* ให้แสดงทับองค์ประกอบอื่น */
    width: 80vw; /* ให้กว้างขึ้นตาม viewport */
    max-width: 350px;
  }

  #gameOverlay div {
    margin-bottom: 1.5vh;
    font-size: min(4.5vw, 3.5vh);
    color: #ff4d4d;
    text-shadow: 1px 1px 0px #800;
  }

  /* --- Top UI (Score, Level, Next Piece) --- */
  #topUI {
    display: flex;
    flex-direction: row;
    align-items: flex-end;
    justify-content: space-around;
    gap: 1vh;
    margin-bottom: 1vh; /* ลด margin ล่าง */
    width: 100%;
    padding: 1vh 2vw;
    box-sizing: border-box;
    flex-shrink: 0; /* ไม่ให้หดตัว */
  }

  #scoreLevel {
    font-size: min(3.8vw, 2.3vh);
    line-height: 1.3;
    text-align: left;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 1vh 2vw;
    border-radius: 6px;
    border: 2px solid #555;
    box-shadow: inset 0 0 4px rgba(255, 255, 255, 0.2);
    min-width: 25vw;
  }

  #next {
    background-color: #222;
    border: 2px solid #777;
    width: min(17vw, 75px);
    height: min(17vw, 75px);
    box-shadow: 0 0 8px rgba(0, 255, 255, 0.3), inset 0 0 6px rgba(255, 255, 255, 0.1);
    border-radius: 4px;
  }

  /* --- Game Canvas --- */
  #gameContainer {
    display: block;
    border: 3px solid #fff;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
    background-color: #0d0d0d;
    border-radius: 6px;
    overflow: hidden;
    margin-top: 1vh;
    flex-grow: 1; /* ขยายเต็มพื้นที่ที่เหลือ */
    min-height: 0; /* จำเป็นสำหรับ flex item ที่มี flex-grow */
    display: flex; /* ให้ canvas อยู่ตรงกลาง container ได้ */
    justify-content: center;
    align-items: center;
    box-sizing: border-box;
  }

  #game {
    background-color: #1a1a1a;
    /* Canvas size will be set by JS based on its container */
  }

  /* --- Controls --- */
  #controls {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(2, min-content); /* ทำให้แถวสูงเท่าที่เนื้อหาต้องการ */
    gap: 1.2vh;
    margin-top: 1.5vh;
    padding: 1.5vh 2vw;
    width: 100%; /* ใช้ 100% ของ mainGameWrapper */
    box-sizing: border-box;
    flex-shrink: 0; /* ไม่ให้หดตัว */
  }

  #controls button, #menuScreen button, #gameOverlay button {
    width: 100%;
    height: min(14vw, 7vh); /* ปรับขนาดปุ่มให้เล็กลงอีก */
    font-family: 'Press Start 2P', cursive;
    font-size: min(4vw, 3vh);
    background-color: #007bff;
    color: #fff;
    border: none;
    border-radius: 6px;
    box-shadow: 0 0.8vw 0px #0056b3;
    cursor: pointer;
    transition: all 0.1s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    text-shadow: 0.2vw 0.2vw 0px rgba(0,0,0,0.3);
    box-sizing: border-box;
  }

  #controls button:active, #menuScreen button:active, #gameOverlay button:active {
    background-color: #0056b3;
    transform: translateY(0.3vw);
    box-shadow: 0 0.2vw 0px #003f8e;
  }

  /* Grid Area สำหรับปุ่มควบคุม */
  #pauseBtn, #resumeBtn { grid-column: 1; grid-row: 1; }
  #rotateBtn { grid-column: 2; grid-row: 1; }
  #hardDropBtn { grid-column: 3; grid-row: 1; }
  #leftBtn { grid-column: 1; grid-row: 2; }
  #downBtn { grid-column: 2; grid-row: 2; }
  #rightBtn { grid-column: 3; grid-row: 2; }

  /* Responsive adjustments for extremely small screens or landscape mode */
  @media (max-height: 500px) and (orientation: landscape) {
    body {
        flex-direction: row; /* เปลี่ยนเป็นแนวนอน */
        justify-content: center;
        align-items: center;
        padding: 1vw 1vh;
    }
    h1 {
        display: none; /* ซ่อนชื่อเกมเมื่อเป็นแนวนอนและจอเล็ก */
    }
    #mainGameWrapper {
        flex-direction: row; /* Wrapper เป็น flex row ในแนวนอน */
        justify-content: center;
        align-items: flex-start;
        height: 100%; /* ใช้ความสูงเต็ม */
        max-width: 95vw;
    }
    #topUI {
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        margin: 0;
        padding: 0.5vh 0.5vw;
        height: 100%; /* ให้ topUI ยืดเต็มความสูงด้านข้าง */
        min-width: unset;
        max-width: 25vw; /* จำกัดความกว้างด้านข้าง */
        overflow-y: auto; /* เผื่อเนื้อหาเยอะ */
    }
    #scoreLevel {
        margin-bottom: 1vh;
        font-size: min(2.5vw, 1.8vh);
        min-width: unset;
        text-align: center;
        padding: 0.8vh 1vw;
    }
    #next {
        width: min(10vw, 10vh);
        height: min(10vw, 10vh);
        margin-top: 1vh;
    }
    #gameContainer {
        margin-top: 0;
        margin-left: 1vw;
        margin-right: 1vw;
        max-width: 60vw; /* ให้ Canvas ใช้พื้นที่กว้างขึ้น */
        max-height: 95vh; /* ใช้ความสูงเกือบเต็ม */
        flex-grow: 1;
    }
    #controls {
        grid-template-columns: repeat(2, 1fr); /* 2 คอลัมน์สำหรับแนวนอน */
        grid-template-rows: repeat(3, auto); /* 3 แถว */
        gap: 1vw;
        margin-top: 0;
        margin-left: 1vw;
        padding: 1vw;
        max-width: 35vw; /* ลดความกว้างของส่วนควบคุมลง */
        height: 90vh; /* ยืดเกือบเต็มความสูง */
        overflow-y: auto; /* เผื่อเนื้อหาเยอะ */
    }
    #controls button {
        height: min(10vw, 15vh);
        font-size: min(3.5vw, 4vh);
    }

    #pauseBtn, #resumeBtn { grid-column: 1; grid-row: 1; }
    #rotateBtn { grid-column: 2; grid-row: 1; }
    #hardDropBtn { grid-column: 1 / span 2; grid-row: 2; }
    #leftBtn { grid-column: 1; grid-row: 3; }
    #downBtn { grid-column: 2; grid-row: 3; }
    #rightBtn { display: none; } /* ซ่อนปุ่มขวาเพื่อประหยัดพื้นที่ ถ้าจำเป็น */
  }

</style>
</head>
<body>

<div id="menuScreen">
  <h1>TETRIS MOBILE</h1>
  <button id="startBtn">เริ่มเล่น</button>
</div>

<div id="gameOverlay" class="hidden">
  <div>เกมจบ!</div>
  <div>คะแนนสุดท้าย: <span id="finalScore">0</span></div>
  <button id="restartBtn">เล่นใหม่</button>
</div>

<!-- Main Game Wrapper -->
<div id="mainGameWrapper" class="hidden">
  <div id="topUI">
    <div id="scoreLevel">
      <div>คะแนน: <span id="score">0</span></div>
      <div>ระดับ: <span id="level">1</span></div>
    </div>
    <canvas id="next" width="90" height="90"></canvas>
  </div>

  <div id="gameContainer">
    <canvas id="game" width="300" height="600"></canvas>
  </div>

  <div id="controls">
    <button id="pauseBtn" title="Pause" aria-label="Pause">⏸️</button>
    <button id="rotateBtn">⟳</button>
    <button id="hardDropBtn">⚡</button>
    <button id="leftBtn">←</button>
    <button id="downBtn">↓</button>
    <button id="rightBtn">→</button>
    <button id="resumeBtn" title="Play" aria-label="Play" class="hidden">▶️</button>
  </div>
</div>

<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const finalScoreEl = document.getElementById('finalScore');
  const menuScreen = document.getElementById('menuScreen');
  const gameOverlay = document.getElementById('gameOverlay');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const topUIDiv = document.getElementById('topUI');
  const gameContainer = document.getElementById('gameContainer');
  const controls = document.getElementById('controls');
  const hardDropBtn = document.getElementById('hardDropBtn');
  const body = document.body;
  const mainGameWrapper = document.getElementById('mainGameWrapper'); // อ้างอิงถึง wrapper ใหม่

  let BLOCK_SIZE;
  const COLS = 10;
  const ROWS = 20;

  function setCanvasDimensions() {
    // Canvas ควรจะเติมเต็มพื้นที่ของ gameContainer
    // จึงคำนวณ BLOCK_SIZE จากขนาดของ gameContainer
    const containerWidth = gameContainer.clientWidth;
    const containerHeight = gameContainer.clientHeight;

    // คำนวณ BLOCK_SIZE โดยพยายามรักษาสัดส่วน 1:2
    // เลือก BLOCK_SIZE ที่เล็กที่สุดจากการคำนวณทั้งแนวตั้งและแนวนอน
    let calculatedBlockSizeByWidth = Math.floor(containerWidth / COLS);
    let calculatedBlockSizeByHeight = Math.floor(containerHeight / ROWS);

    BLOCK_SIZE = Math.min(calculatedBlockSizeByWidth, calculatedBlockSizeByHeight);
    
    // ตรวจสอบให้แน่ใจว่า BLOCK_SIZE ไม่เป็น 0 หรือเป็นค่าลบ
    BLOCK_SIZE = Math.max(10, BLOCK_SIZE); 

    canvas.width = BLOCK_SIZE * COLS;
    canvas.height = BLOCK_SIZE * ROWS;

    // ตั้งค่าขนาด nextCanvas ให้สอดคล้องกัน (ถ้าจำเป็น)
    // nextCanvas.width = BLOCK_SIZE * 4; // ขนาด 4x4 blocks
    // nextCanvas.height = BLOCK_SIZE * 4;
  }

  // Initial set and on resize
  setCanvasDimensions();
  window.addEventListener('resize', setCanvasDimensions);


  // Game logic variables and functions (unchanged from previous version)
  const SHAPES = [
    [],
    [[1,1,1,1]], // I
    [[1,1,0],[0,1,1]], // Z
    [[0,1,1],[1,1,0]], // S
    [[1,1,1],[0,1,0]], // T
    [[1,1],[1,1]], // O
    [[1,0,0],[1,1,1]], // L
    [[0,0,1],[1,1,1]], // J
  ];
  const COLORS = [
    null,
    '#00ffff', // I - Cyan
    '#ff0000', // Z - Red
    '#00ff00', // S - Green
    '#aa00ff', // T - Purple
    '#ffff00', // O - Yellow
    '#ff8800', // L - Orange
    '#0000ff', // J - Blue
  ];

  let board = [];
  let currentPiece = null;
  let nextPiece = null;
  let score = 0;
  let level = 1;
  let linesCleared = 0;
  let gameOver = false;
  let dropInterval = 1000;
  let lastDropTime = 0;
  let isPaused = false;
  let animationFrameId = null;

  function resetBoard() {
    board = [];
    for(let r=0; r<ROWS; r++) {
      board.push(new Array(COLS).fill(0));
    }
  }

  function randomPiece() {
    const id = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
    return {
      id: id,
      shape: SHAPES[id],
      color: COLORS[id],
      x: Math.floor(COLS/2) - Math.ceil(SHAPES[id][0].length/2),
      y: 0
    };
  }

  function drawBlock(x, y, color, context=ctx, alpha = 1) {
    context.fillStyle = color;
    context.globalAlpha = alpha;
    context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    context.strokeStyle = 'rgba(255,255,255,0.15)'; /* ขอบบล็อก */
    context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    context.globalAlpha = 1;
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        if(board[r][c]) {
          drawBlock(c, r, COLORS[board[r][c]]);
        }
      }
    }
  }

  function drawPiece(piece, context=ctx, alpha = 1) {
    piece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value) {
          drawBlock(piece.x + x, piece.y + y, piece.color, context, alpha);
        }
      });
    });
  }

  function drawNextPiece() {
    nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    if(!nextPiece) return;

    // Calculate offset to center the piece in nextCanvas
    const pieceWidth = nextPiece.shape[0].length;
    const pieceHeight = nextPiece.shape.length;
    const blockSizeNext = nextCanvas.width / 4; // Block size for 4x4 area

    let startX = (nextCanvas.width - pieceWidth * blockSizeNext) / 2;
    let startY = (nextCanvas.height - pieceHeight * blockSizeNext) / 2;

    nextPiece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value) {
          nextCtx.fillStyle = nextPiece.color;
          nextCtx.fillRect(startX + x * blockSizeNext, startY + y * blockSizeNext, blockSizeNext - 2, blockSizeNext - 2);
          nextCtx.strokeStyle = 'rgba(255,255,255,0.2)';
          nextCtx.strokeRect(startX + x * blockSizeNext, startY + y * blockSizeNext, blockSizeNext - 2, blockSizeNext - 2);
        }
      });
    });
  }

  function collides(piece, board, offsetX, offsetY) {
    for(let y=0; y < piece.shape.length; y++) {
      for(let x=0; x < piece.shape[y].length; x++) {
        if(piece.shape[y][x]) {
          const newX = piece.x + x + offsetX;
          const newY = piece.y + y + offsetY;
          if(newX < 0 || newX >= COLS || newY >= ROWS) return true;
          if(newY >= 0 && board[newY][newX]) return true;
        }
      }
    }
    return false;
  }

  function mergePiece(piece, board) {
    piece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value && piece.y + y >= 0) {
          board[piece.y + y][piece.x + x] = piece.id;
        }
      });
    });
  }

  function rotate(piece) {
    const newShape = [];
    const rows = piece.shape.length;
    const cols = piece.shape[0].length;
    for(let x=0; x<cols; x++) {
      newShape[x] = [];
      for(let y=rows-1; y>=0; y--) {
        newShape[x][rows - 1 - y] = piece.shape[y][x];
      }
    }
    return newShape;
  }

  function rotatePiece() {
    if(isPaused || gameOver) return;
    const rotatedShape = rotate(currentPiece);
    const originalShape = currentPiece.shape;
    currentPiece.shape = rotatedShape;

    // Wall Kick - Check for collision and try to shift slightly
    const kicks = [
        [0, 0], // No kick
        [-1, 0], // Kick left
        [1, 0],  // Kick right
        [0, -1], // Kick up
        [-2, 0], // Double kick left
        [2, 0]   // Double kick right
    ];

    let rotatedSuccessfully = false;
    for (let i = 0; i < kicks.length; i++) {
        const [offsetX, offsetY] = kicks[i];
        if (!collides(currentPiece, board, offsetX, offsetY)) {
            currentPiece.x += offsetX;
            currentPiece.y += offsetY;
            rotatedSuccessfully = true;
            break;
        }
    }

    if (!rotatedSuccessfully) {
        currentPiece.shape = originalShape; // Revert if all kicks fail
        playSound('fail');
    } else {
        playSound('rotate');
    }
    draw();
  }

  function movePiece(offsetX, offsetY) {
    if(isPaused || gameOver) return;
    if(!collides(currentPiece, board, offsetX, offsetY)) {
      currentPiece.x += offsetX;
      currentPiece.y += offsetY;
      if (offsetY === 1) playSound('down');
      else if (offsetX !== 0) playSound('move');
      draw();
      return true;
    } else {
      if(offsetY === 1) { // If piece hits bottom or other blocks
        lockPiece();
      }
      return false;
    }
  }

  function hardDrop() {
    if(isPaused || gameOver) return;
    let linesDropped = 0;
    while (!collides(currentPiece, board, 0, 1)) {
      currentPiece.y++;
      linesDropped++;
    }
    score += linesDropped * 2; // Score for hard drop
    lockPiece();
    playSound('harddrop');
    draw();
  }

  function lockPiece() {
    mergePiece(currentPiece, board);
    clearLines();
    spawnNextPiece();
    if(collides(currentPiece, board, 0, 0)) {
      gameOver = true;
      showGameOver();
      playSound('gameover');
    } else {
      playSound('lock');
    }
  }

  function clearLines() {
    let lines = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (!board[y][x]) continue outer;
      }
      board.splice(y, 1);
      board.unshift(new Array(COLS).fill(0));
      lines++;
      y++;
    }

    if (lines > 0) {
      linesCleared += lines;
      // Score based on multiple lines cleared
      switch (lines) {
        case 1: score += 100 * level; break;
        case 2: score += 300 * level; break;
        case 3: score += 500 * level; break;
        case 4: score += 800 * level; break; // Tetris
      }

      const newLevel = Math.floor(linesCleared / 10) + 1;
      if (newLevel !== level) {
        level = newLevel;
        dropInterval = Math.max(50, 1000 - (level - 1) * 70); // Min drop interval 50ms
      }

      scoreEl.textContent = score;
      levelEl.textContent = level;
      playSound('clear');
    }
  }

  function getGhostPiece() {
    const ghost = { ...currentPiece };
    while (!collides(ghost, board, 0, 1)) {
      ghost.y++;
    }
    return ghost;
  }

  function spawnNextPiece() {
    currentPiece = nextPiece;
    currentPiece.x = Math.floor(COLS/2) - Math.ceil(currentPiece.shape[0].length/2);
    currentPiece.y = 0;
    nextPiece = randomPiece();
    drawNextPiece();
  }

  function updateScoreLevel() {
    scoreEl.textContent = score;
    levelEl.textContent = level;
  }

  function draw() {
    drawBoard();
    if (!gameOver && !isPaused) {
      const ghostPiece = getGhostPiece();
      drawPiece(ghostPiece, ctx, 0.2); // Draw ghost piece with transparency
      drawPiece(currentPiece);
    }
  }

  function gameLoop(timestamp) {
    if(gameOver || isPaused) {
      animationFrameId = requestAnimationFrame(gameLoop);
      return;
    }
    if(!lastDropTime) lastDropTime = timestamp;
    const delta = timestamp - lastDropTime;
    if(delta > dropInterval) {
      movePiece(0,1);
      lastDropTime = timestamp;
    }
    draw();
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  function preloadSounds() {
    for (const key in sounds) {
      if (sounds[key].src) {
        sounds[key].load();
      }
    }
  }

  function startGame() {
    resetBoard();
    score = 0;
    level = 1;
    linesCleared = 0;
    dropInterval = 1000;
    lastDropTime = 0;
    gameOver = false;
    isPaused = false;
    currentPiece = randomPiece();
    nextPiece = randomPiece();
    
    // Hide menu, show game elements
    menuScreen.classList.add('hidden');
    gameOverlay.classList.add('hidden');
    mainGameWrapper.classList.remove('hidden'); // แสดง wrapper หลัก
    
    // ต้องเรียก setCanvasDimensions หลังจากที่ mainGameWrapper แสดงผลแล้ว
    // เพื่อให้ getBoundingClientRect() ได้ค่าที่ถูกต้อง
    setCanvasDimensions(); 
    drawNextPiece();
    updateScoreLevel();
    
    // TopUI, GameContainer, Controls อยู่ภายใต้ mainGameWrapper แล้ว
    // ซึ่ง mainGameWrapper มี display: flex อยู่แล้ว จึงไม่ต้องเปลี่ยนตรงนี้อีก
    // แต่ถ้าต้องการควบคุม display ของแต่ละอันแยกกัน ก็ยังทำได้
    topUIDiv.style.display = 'flex'; // หรือ remove 'hidden' class
    gameContainer.style.display = 'flex'; // หรือ remove 'hidden' class
    controls.style.display = 'grid'; // หรือ remove 'hidden' class

    pauseBtn.classList.remove('hidden');
    resumeBtn.classList.add('hidden');

    preloadSounds();
    animationFrameId = requestAnimationFrame(gameLoop);
    playSound('start');
  }

  function showGameOver() {
    gameOverlay.classList.remove('hidden');
    finalScoreEl.textContent = score;
    mainGameWrapper.classList.add('hidden'); // ซ่อนเกมหลักเมื่อจบเกม
  }

  function pauseGame() {
    if(gameOver) return;
    isPaused = true;
    pauseBtn.classList.add('hidden');
    resumeBtn.classList.remove('hidden');
    playSound('pause');
  }

  function resumeGame() {
    if(gameOver) return;
    isPaused = false;
    lastDropTime = performance.now();
    pauseBtn.classList.remove('hidden');
    resumeBtn.classList.add('hidden');
    playSound('resume');
    requestAnimationFrame(gameLoop); // Restart animation frame
  }

  // Sound files (ensure these files exist in a 'sounds/' folder)
  const sounds = {
    move: new Audio('sounds/move.wav'),
    rotate: new Audio('sounds/rotate.wav'),
    down: new Audio('sounds/down.wav'),
    clear: new Audio('sounds/clear.wav'),
    fail: new Audio('sounds/fail.wav'),
    start: new Audio('sounds/start.wav'),
    pause: new Audio('sounds/pause.wav'),
    resume: new Audio('sounds/resume.wav'),
    gameover: new Audio('sounds/gameover.wav'),
    harddrop: new Audio('sounds/harddrop.wav'),
    lock: new Audio('sounds/lock.wav'),
  };

  function playSound(name) {
    const sound = sounds[name];
    if(sound) {
      // Clone node to allow overlapping playback for rapid actions (e.g., fast down moves)
      const clonedSound = sound.cloneNode();
      clonedSound.volume = 0.7; // Reduce volume slightly if sounds are too loud
      clonedSound.play().catch(e => console.log("Sound playback failed for", name, ":", e));
    }
  }

  // Event listeners for touch controls
  startBtn.addEventListener('click', startGame);
  restartBtn.addEventListener('click', () => {
    gameOverlay.classList.add('hidden');
    startGame();
  });

  pauseBtn.addEventListener('click', pauseGame);
  resumeBtn.addEventListener('click', resumeGame);

  document.getElementById('leftBtn').addEventListener('click', () => movePiece(-1,0));
  document.getElementById('rightBtn').addEventListener('click', () => movePiece(1,0));
  document.getElementById('rotateBtn').addEventListener('click', rotatePiece);
  document.getElementById('downBtn').addEventListener('click', () => movePiece(0,1));
  hardDropBtn.addEventListener('click', hardDrop);

  // Prevent scrolling on mobile when interacting with controls
  window.addEventListener('touchmove', function(e){
    // Only prevent default if the touch is within the game container or controls
    if(gameContainer.contains(e.target) || controls.contains(e.target) || topUIDiv.contains(e.target)) {
      e.preventDefault();
    }
  }, { passive:false });

  // Initial setup: Ensure menu screen is visible at start, others are hidden
  document.addEventListener('DOMContentLoaded', () => {
    menuScreen.classList.remove('hidden');
    gameOverlay.classList.add('hidden');
    mainGameWrapper.classList.add('hidden'); // ซ่อน wrapper หลักไว้ก่อน
    setCanvasDimensions(); // Set initial canvas size on load
  });

</script>
</body>
</html>
