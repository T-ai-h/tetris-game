<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tetris Mobile Friendly</title>
<style>
  body {
    margin: 0; padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #222;
    color: white;
    font-family: sans-serif;
  }
  canvas {
    background: #000;
    display: block;
    margin: 20px auto;
  }
  #controls {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
  }
  button {
    width: 60px; height: 60px;
    font-size: 20px;
    border-radius: 10px;
    border: none;
    background: #555;
    color: white;
    user-select: none;
    touch-action: manipulation;
  }
  button:active {
    background: #999;
  }
  #gameOverlay {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.8);
    color: white;
    font-size: 24px;
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10;
    flex-direction: column;
  }
</style>
</head>
<body>

<canvas id="game" width="300" height="600"></canvas>
<canvas id="next" width="120" height="120"></canvas>

<div id="controls">
  <button id="leftBtn">◀️</button>
  <button id="downBtn">⬇️</button>
  <button id="rightBtn">▶️</button>
  <button id="rotateBtn">⟳</button>
</div>

<div id="gameOverlay">
  <div>Game Over</div>
  <button id="restartBtn">Restart</button>
</div>

<div>Score: <span id="score">0</span> | Level: <span id="level">1</span></div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const nextCanvas = document.getElementById("next");
const nextCtx = nextCanvas.getContext("2d");

const ROWS = 20;
const COLS = 10;
const BLOCK_SIZE = 30;
const NEXT_BLOCK_SIZE = 30;

let score = 0;
let level = 1;
const scoreEl = document.getElementById("score");
const levelEl = document.getElementById("level");

const gameOverlay = document.getElementById("gameOverlay");
const restartBtn = document.getElementById("restartBtn");

const colors = [
  null,
  "#00f0f0", // I
  "#0000f0", // J
  "#f0a000", // L
  "#f0f000", // O
  "#00f000", // S
  "#a000f0", // T
  "#f00000", // Z
];

const tetrominoes = [
  [],
  [[1, 1, 1, 1]],                // I
  [[2, 0, 0], [2, 2, 2]],        // J
  [[0, 0, 3], [3, 3, 3]],        // L
  [[4, 4], [4, 4]],              // O
  [[0, 5, 5], [5, 5, 0]],        // S
  [[0, 6, 0], [6, 6, 6]],        // T
  [[7, 7, 0], [0, 7, 7]],        // Z
];

let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));

let currentPiece = null;
let currentX = 0;
let currentY = 0;
let nextPiece = null;

let dropSpeed = 700;
let gameInterval;

const leftBtn = document.getElementById("leftBtn");
const rightBtn = document.getElementById("rightBtn");
const downBtn = document.getElementById("downBtn");
const rotateBtn = document.getElementById("rotateBtn");

function randomPiece() {
  const id = Math.floor(Math.random() * (tetrominoes.length - 1)) + 1;
  return { id: id, shape: tetrominoes[id] };
}

function drawBlock(x, y, colorId, size = BLOCK_SIZE, context = ctx) {
  context.fillStyle = colors[colorId];
  context.fillRect(x * size, y * size, size, size);
  context.strokeStyle = "#222";
  context.lineWidth = 2;
  context.strokeRect(x * size, y * size, size, size);
}

function drawGrid() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (grid[r][c]) {
        drawBlock(c, r, grid[r][c]);
      }
    }
  }
}

function drawPiece(piece, x, y, context = ctx, size = BLOCK_SIZE) {
  piece.shape.forEach((row, dy) => {
    row.forEach((val, dx) => {
      if (val) drawBlock(x + dx, y + dy, piece.id, size, context);
    });
  });
}

function drawNextPiece() {
  nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
  const shape = nextPiece.shape;
  const offsetX = Math.floor((nextCanvas.width / NEXT_BLOCK_SIZE - shape[0].length) / 2);
  const offsetY = Math.floor((nextCanvas.height / NEXT_BLOCK_SIZE - shape.length) / 2);
  drawPiece(nextPiece, offsetX, offsetY, nextCtx, NEXT_BLOCK_SIZE);
}

function validMove(piece, x, y) {
  for (let r = 0; r < piece.shape.length; r++) {
    for (let c = 0; c < piece.shape[r].length; c++) {
      if (piece.shape[r][c]) {
        let newX = x + c;
        let newY = y + r;
        if (newX < 0 || newX >= COLS || newY >= ROWS) return false;
        if (newY >= 0 && grid[newY][newX]) return false;
      }
    }
  }
  return true;
}

function lockPiece(piece, x, y) {
  piece.shape.forEach((row, r) => {
    row.forEach((val, c) => {
      if (val && y + r >= 0) {
        grid[y + r][x + c] = piece.id;
      }
    });
  });
}

function clearLines() {
  let lines = 0;
  outer: for (let r = ROWS - 1; r >= 0; r--) {
    for (let c = 0; c < COLS; c++) {
      if (!grid[r][c]) continue outer;
    }
    grid.splice(r, 1);
    grid.unshift(Array(COLS).fill(0));
    lines++;
    r++;
  }
  if (lines > 0) {
    score += lines * 10;
    scoreEl.textContent = score;
    updateSpeed();
  }
}

function rotate(piece) {
  const oldShape = piece.shape;
  const rows = oldShape.length;
  const cols = oldShape[0].length;

  let newShape = [];
  for (let x = 0; x < cols; x++) {
    newShape[x] = [];
    for (let y = rows - 1; y >= 0; y--) {
      newShape[x][rows - 1 - y] = oldShape[y][x];
    }
  }

  return newShape;
}

function resetPiece() {
  currentPiece = nextPiece || randomPiece();
  nextPiece = randomPiece();
  drawNextPiece();
  currentX = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
  currentY = -1;
  if (!validMove(currentPiece, currentX, currentY)) {
    gameOver();
  }
}

function gameOver() {
  gameOverlay.style.display = "flex";
  clearInterval(gameInterval);
}

restartBtn.addEventListener("click", () => {
  gameOverlay.style.display = "none";

  grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
  score = 0;
  level = 1;
  scoreEl.textContent = score;
  levelEl.textContent = level;

  nextPiece = randomPiece();
  resetPiece();
  updateSpeed();
  draw();
});

let uiMoveInterval = null;

// สำหรับปุ่มกดค้าง (กดซ้าย ขวา และลง)
function startContinuousMove(direction) {
  if (gameOverlay.style.display === "flex") return;
  if (uiMoveInterval) return;

  handleMove(direction);
  uiMoveInterval = setInterval(() => {
    handleMove(direction);
  }, 150);
}

function stopContinuousMove() {
  if (uiMoveInterval) {
    clearInterval(uiMoveInterval);
    uiMoveInterval = null;
  }
}

// ปุ่มซ้าย ขวา กดค้างได้ (mousedown/touchstart)
leftBtn.addEventListener("mousedown", () => startContinuousMove("left"));
leftBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startContinuousMove("left"); });
leftBtn.addEventListener("mouseup", stopContinuousMove);
leftBtn.addEventListener("mouseleave", stopContinuousMove);
leftBtn.addEventListener("touchend", stopContinuousMove);
leftBtn.addEventListener("touchcancel", stopContinuousMove);

// ปุ่มขวา กดค้างได้
rightBtn.addEventListener("mousedown", () => startContinuousMove("right"));
rightBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startContinuousMove("right"); });
rightBtn.addEventListener("mouseup", stopContinuousMove);
rightBtn.addEventListener("mouseleave", stopContinuousMove);
rightBtn.addEventListener("touchend", stopContinuousMove);
rightBtn.addEventListener("touchcancel", stopContinuousMove);

// ปุ่มลง กดค้างได้ (เหมือนข้างบน)
downBtn.addEventListener("mousedown", () => startContinuousMove("down"));
downBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startContinuousMove("down"); });
downBtn.addEventListener("mouseup", stopContinuousMove);
downBtn.addEventListener("mouseleave", stopContinuousMove);
downBtn.addEventListener("touchend", stopContinuousMove);
downBtn.addEventListener("touchcancel", stopContinuousMove);

// ปุ่มหมุนบล็อก (click หรือ touch)
rotateBtn.addEventListener("click", () => handleMove("rotate"));
rotateBtn.addEventListener("touchstart", (e) => { e.preventDefault(); handleMove("rotate"); });

function handleMove(direction) {
  if (gameOverlay.style.display === "flex") return;

  if (direction === "left") {
    if (validMove(currentPiece, currentX - 1, currentY)) currentX--;
  } else if (direction === "right") {
    if (validMove(currentPiece, currentX + 1, currentY)) currentX++;
  } else if (direction === "down") {
    update();  // เลื่อนชิ้นส่วนลงและจัดการล็อกชิ้นส่วนอัตโนมัติ
    return;     // ออกจากฟังก์ชันเลยเพื่อไม่ให้ draw() ซ้ำ
  } else if (direction === "rotate") {
    const rotatedShape = rotate(currentPiece);
    const testPiece = { ...currentPiece, shape: rotatedShape };

    if (validMove(testPiece, currentX, currentY)) {
      currentPiece.shape = rotatedShape;
    } else if (validMove(testPiece, currentX - 1, currentY)) {
      currentX--;
      currentPiece.shape = rotatedShape;
    } else if (validMove(testPiece, currentX + 1, currentY)) {
      currentX++;
      currentPiece.shape = rotatedShape;
    }
  }
  draw();
}

function update() {
  if (validMove(currentPiece, currentX, currentY + 1)) {
    currentY++;
  } else {
    lockPiece(currentPiece, currentX, currentY);
    clearLines();
    resetPiece();
  }
  draw();
}

function draw() {
  drawGrid();
  drawPiece(currentPiece, currentX, currentY);
}

function updateSpeed() {
  level = Math.floor(score / 50) + 1;
  levelEl.textContent = level;

  dropSpeed = Math.max(100, 700 - (level - 1) * 50);
  clearInterval(gameInterval);
  gameInterval = setInterval(update, dropSpeed);

  updateBackground();
}

function updateBackground() {
  const backgrounds = [
    "#000000",
    "#0b3d0b",
    "#3d3d00",
    "#3d2200",
    "#4d003d",
    "#2e1b4d",
    "#004d66",
  ];

  let bgColor = backgrounds[Math.min(level - 1, backgrounds.length - 1)];
  canvas.style.background = bgColor;
}

// เริ่มเกม
nextPiece = randomPiece();
resetPiece();
updateSpeed();
draw();

</script>
</body>
</html>
